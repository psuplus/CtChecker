* Adding Labels 
** Infoflow.cpp/h
   Added a labeling function to break down AbstractLocs
*** Type information
    offset : type(s) (comma separated) : flags
**** Offset
     This can be either Collapsed, a number of bytes or VOID
     *VOIDTB==TE* ::= TyMap.begin() == TyMap.end()
     *#bytes*     ::= Where the datas structure starts wrt ptr
     *COLLAPSED*  ::= Node has folded in DSA Graph

     Flags
     S ::= AllocaNode
     M ::= ModifiedNode
     R ::= ReadNode
     H ::= HeapNode
     E ::= ExternalNode
**** Examples
     In the taint analysis the use of a simple integer:
     0: i32,  : SR-->  %0 = load i32, i32* %dtx, align 4, !dbg !27

     A struct with a pointer and then an integer 
     This shows the offset of the number is located at 0 bytes from the start
     The type is i32
     The S stands for AllocaNode (Stack)
     The R stands for ReadNode

* Tests
  From the Tests below it shows that the constraint changes when a pointer
  argument is used. The type of the local variable userpass in the function is
  not able to be determined from the AbstractLoc.
** No ptr wit call to getpasswd
   - Results: 
     Length of Set for dtx is 1
     Matching dtx with dtx: 0: i32,  : SR
     Least solution with explicit contraints
     Tainted! test.c line 10
     Tainted! Function taint_branch Arg: x
     Least solution with implicit contraints
     Tainted! test.c line 10
     Tainted! Function taint_branch Arg: x

   - Notes:
     This test flags both the function argument and the call correctly
     The constraint added to the set matches the lines we expect.
     0: i32,  : SR-->  %0 = load i32, i32* %dtx, align 4, !dbg !27
     
     The constraint where the string is loaded doesn't have the AllocA flag set.
     VOIDTB==TE: E-->  %2 = load i8, i8* %1, align 1, !dbg !41
** No ptr with fixed string
   - Results: 
     Length of Set for dtx is 1
     Matching dtx with dtx: 0: i32,  : SR
     Least solution with explicit contraints
     Tainted! test.c line 10
     Tainted! Function taint_branch Arg: x
     Least solution with implicit contraints
     Tainted! test.c line 10
     Tainted! Function taint_branch Arg: x

   - Notes:
     This test flags both the function argument and the call correctly
     The constraint added to the set matches the lines we expect.
     0: i32,  : SR-->  %0 = load i32, i32* %dtx, align 4, !dbg !27
     
     The constraint where the string is loaded doesn't have the AllocA flag set.
     VOIDTB==TE: E-->  %2 = load i8, i8* %1, align 1, !dbg !41
** No ptr with different string
   - Results: 
     Length of Set for dtx is 1
     Matching dtx with dtx: 0: i32,  : SR
     Least solution with explicit contraints
     Tainted! test.c line 10
     Tainted! Function taint_branch Arg: x
     Least solution with implicit contraints
     Tainted! test.c line 10
     Tainted! Function taint_branch Arg: x

   - Notes:
     This test flags both the function argument and the call correctly
     The constraint added to the set matches the lines we expect.
     0: i32,  : SR-->  %0 = load i32, i32* %dtx, align 4, !dbg !27
     
     The constraint where the string is loaded doesn't have the AllocA flag set.
     0: i8,   array: GR2@.str = private unnamed_addr constant [6 x i8] c"Hello\00", align 1-->  %2 = load i8, i8* %1, align 1, !dbg !40
** Ptr with call to getpasswd
   - Results: 
     Length of Set for dtx is 1
     Matching dtx with dtx: VOIDTB==TE: SE
     Least solution with explicit contraints
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Least solution with implicit contraints
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20

   - Notes:
     Function arguments not flagged, instead char* loop flagged
     VOIDTB==TE: SE-->  %2 = load i8, i8* %1, align 1, !dbg !42

** Ptr with fixed string
   Line 16: char* userpass = "Hello" instead of getpasswd()
   The fixed string is "Hello" to match the getpasswd string.

   - Results:
     Length of Set for dtx is 1
     Matching dtx with dtx: VOIDTB==TE: SE
     Least solution with explicit contraints
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Least solution with implicit contraints
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20
     Tainted! test.c line 20

   - Notes:
     VOIDTB==TE: SE-->  %2 = load i8, i8* %1, align 1, !dbg !41
     For some reason the node for this string is not tracked by analysis

** Ptr with different string
   Changes: getpasswd returns "Hell" instead of "Hello"

   - Results:
     Length of Set for dtx is 1
     Least solution with explicit constraints
     Least solution with implicit constraints
     
   - Notes: 
     In this case not even the function argument is flagged, which may also be incorrect.

     0: i8,   array: GR2@.str = private unnamed_addr constant [6 x i8] c"Hello\00", align 1-->  %2 = load i8, i8* %1, align 1, !dbg !41
     String is tracked by analysis and type matches up with what we expect
     
* Erroneous constraint
  In taintanalysis.cpp the last constraint is added to the rest of the
  set. The datastructure that is used to map this is from Infoflow.cpp.

  In Infoflow.cpp the locsForValue is a wrapper for the PointsToInterface.cpp
  function that returns a set of locations for a LLVM::Value.



  

  

 
   
