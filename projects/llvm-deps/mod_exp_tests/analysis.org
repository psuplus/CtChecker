* OpenSSL 0.9.7c
** RSA_eay.c test
   Tainted: p, q
   Untrusted: r1, m1
   rsa_eay.c line 329 - RSA_eay_private_encrypt: NULL check p
   rsa_eay.c line 330 - RSA_eay_private_encrypt: NULL check q
   rsa_eay.c line 442 - RSA_eay_privane_decrypt: NULL check p
   rsa_eay.c line 443 - RSA_eay_private_decrypt: NULL check q
   rsa_eay.c line 480 - RSA_eay_private_decrypt: if (r > 0)
   rsa_eay.c line 579 - RSA_eay_public_decrypt: if (r >  0)
   rsa_eay.c line 612 - RSA_eay_mod_exp: if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->p,ctx))
   rsa_eay.c line 636 - RSA_eay_mod_exp: if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->q,ctx))
   rsa_eay.c line 656 - RSA_eay_mod_exp: if (!BN_mod(&r1,I,rsa->q,ctx))
   rsa_eay.c line 657 - RSA_eay_mod_exp: if (!rsa->meth->bn_mod_exp(&m1,&r1,rsa->dmq1,rsa->q,ctx, rsa->_method_mod_q))
   rsa_eay.c line 660 - RSA_eay_mod_exp: if (!BN_mod(&r1,I,rsa->p,ctx))
   rsa_eay.c line 661 - RSA_eay_mod_exp: if (!rsa->meth->bn_mod_exp(r0,&r1,rsa->dmp1,rsa->p,ctx, rsa->_method_mod_p))
   rsa_eay.c line 668 - RSA_eay_mod_exp: if (!BN_add(r0,r0,rsa->p))
   rsa_eay.c line 671 - RSA_eay_mod_exp: if (!BN_mod(r0,&r1,rsa->p,ctx))
   rsa_eay.c line 680 - RSA_eay_mod_exp: if (!BN_add(r0,r0,rsa->p))
   rsa_eay.c line 681 - RSA_eay_mod_exp: if (!BN_mul(&r1,r0,rsa->q,ctx))
** bn_exp.c test
*** *Commit* caad0843b7 Tainted/Untrusted :: a, p  - p is private key exponent, a plaintext padded
    bn_exp.c line 134 - BN_exp: if (BN_is_odd(p))  - potential timing channel
    bn_exp.c line 406 - BN_mod_exp_mont: if (BN_is_zero(aa)) - false positive
    bn_exp.c line 537 - BN_mod_exp_mont_word: if (a == 0) - seems like a false positive

    BN_mod_exp_mont_word - calculating r * w  potential for timing attack
    bn_exp.c line 567 - BN_mod_exp_mont_word: if ((next_w/w) != w) -  Detecting Overflow - potential timing
    bn_exp.c line 571 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) tainted w flows from a
    bn_exp.c line 576 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m)) - tainted w flows from a
    bn_exp.c line 590 - BN_mod_exp_mont_word: if ((next_w/a) != w) - Detecting Overflow - potential timing
    bn_exp.c line 594 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 599 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_exp.c line 608 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 612 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 617 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
*** *Commit* caad0843b7 Tainted/Untrusted: a, m, p
    bn_exp.c line 134 - BN_exp: if (BN_is_odd(p))
    bn_exp.c line 204 - BN_mod_exp: if (BN_is_odd(m))
    bn_exp.c line 368 - if (!(m->d[0] & 1))
    bn_exp.c line 406 - if (BN_is_zero(aa))
    bn_exp.c line 523 - BN_mod_exp_mont_word: if (m->top == 0 || !(m->d[0] & 1))
    bn_exp.c line 537 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 567 - BN_mod_exp_mont_word: if ((next_w/w) != w)
    bn_exp.c line 571 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 576 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 590 - BN_mod_exp_mont_word: if ((next_w/a) != w)
    bn_exp.c line 594 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 599 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 608 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 612 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 617 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
*** *Commit* caad0843b7 Tainted: p, m :: Untrusted: a
    bn_exp.c line 537 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c like 567 - BN_mod_exp_mont_word: if ((next_w/w) != w)
    bn_exp.c line 571 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 576 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 590 - BN_mod_exp_mont_word: if ((next_w/a) != w)
    bn_exp.c line 594 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 599 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 608 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 612 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 617 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
*** *commit* 3798197c41 Tainted/Untrusted: a, p
    bn_exp.c line 125 - BN_exp: if ((r == a) || (r == p))
    bn_exp.c line 134 - BN_exp: if (BN_is_odd(p))
    bn_exp.c line 138 - BN_exp: for (i=1; i<bits; i++)
    bn_exp.c line 141 - BN_exp: if (BN_is_bit_set(p,i))

    bn_exp.c line 207 - BN_mod_exp: if (a->top == 1 && !a->neg)

    bn_exp.c line 264 - BN_mod_exp_recp: if (!BN_nnmod(&(val[0]),a,m,ctx)

    bn_exp.c line 398 - BN_mod_exp_mont: if (a->neg || BN_ucmp(a,m) >= 0)
    bn_exp.c line 400 - BN_mod_exp_mont: if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line 406 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 411 - BN_mod_exp_mont: if (!BN_to_montgomery(&(val[0]),aa,mont,ctx))

    bn_exp.c line 537 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 567 - BN_mod_exp_mont_word: if ((next_w/w) != w)
    bn_exp.c line 571 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 576 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 590 - BN_mod_exp_mont_word: if ((next_w/a) != w)
    bn_exp.c line 594 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 599 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 608 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 612 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 617 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
*** *Commit* 319237301 Tainted/Untrusted: a, p :: Linked with bn_mont.c
    bn_exp.c line  125 - BN_exp: if ((r == a) || (r == p))
    bn_exp.c line  134 - BN_exp: if (BN_is_odd(p))
    bn_exp.c line  138 - BN_exp: for (i=1; i<bits; i++)
    bn_exp.c line  141 - BN_exp: if (BN_is_bit_set(p,i))
    bn_exp.c line  207 - BN_mod_exp: if (a->top == 1 && !a->neg)
    bn_exp.c line  264 - BN_mod_exp_recp: if (!BN_nnmod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
    bn_exp.c line  398 - BN_mod_exp_mont: if (a->neg || BN_ucmp(a,m) >= 0)
    bn_exp.c line  400 - BN_mod_exp_mont: if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line  406 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line  537 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line  567 - BN_mod_exp_mont_word: if ((next_w/w) != w) /* overflow */
    bn_exp.c line  571 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
    bn_exp.c line  576 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_exp.c line  590 - BN_mod_exp_mont_word: if ((next_w/a) != w) /* overflow */
    bn_exp.c line  594 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
    bn_exp.c line  599 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_exp.c line  608 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line  612 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
    bn_exp.c line  617 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_mont.c line   83 - if (a == b)
    bn_mont.c line   85 - if (!BN_sqr(tmp,a,ctx)) goto err;
    bn_mont.c line   89 - if (!BN_mul(tmp,a,b,ctx)) goto err;
    bn_mont.c line  112 - if (!BN_copy(r,a)) goto err;
    bn_mont.c line  121 - if ((al == 0) || (nl == 0)) { r->top=0; return(1); }
    bn_mont.c line  124 - if (bn_wexpand(r,max) == NULL) goto err;
    bn_mont.c line  125 - if (bn_wexpand(ret,max) == NULL) goto err;
    bn_mont.c line  134 - for (i=r->top; i<max; i++) /* memset? XXX */
    bn_mont.c line  146 - for (i=0; i<nl; i++)
    bn_mont.c line  166 - if (((nrp[-1]+=v)&BN_MASK2) >= v)
    bn_mont.c line  170 - if (((++nrp[0])&BN_MASK2) != 0) continue;
    bn_mont.c line  171 - if (((++nrp[1])&BN_MASK2) != 0) continue;
    bn_mont.c line  172 - for (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;
    bn_mont.c line  175 - bn_fix_top(r);
    bn_mont.c line  185 - if (r->top < x)
    bn_mont.c line  191 - for (i=0; i<al; i+=4)
    bn_mont.c line  205 - for (; i<al; i++)
*** *Commit* 319237301 Tainted/Untrusted: a, p :: Linked with bn_mont.c bn_lib.c
    bn_exp.c line  125 - if ((r == a) || (r == p))
    bn_exp.c line  131 - if (BN_copy(v,a) == NULL) goto err;
    bn_exp.c line  134 - if (BN_is_odd(p))
    bn_exp.c line  135 - { if (BN_copy(rr,a) == NULL) goto err; }
    bn_exp.c line  138 - for (i=1; i<bits; i++)
    bn_exp.c line  141 - if (BN_is_bit_set(p,i))
    bn_exp.c line  207 - if (a->top == 1 && !a->neg)
    bn_exp.c line  239 - if (bits == 0)
    bn_exp.c line  252 - if (!BN_copy(aa, m)) goto err;
    bn_exp.c line  264 - if (!BN_nnmod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
    bn_exp.c line  265 - if (BN_is_zero(&(val[0])))
    bn_exp.c line  271 - window = BN_window_bits_for_exponent_size(bits);
    bn_exp.c line  272 - if (window > 1)
    bn_exp.c line  277 - for (i=1; i<j; i++)
    bn_exp.c line  297 - if (BN_is_bit_set(p,wstart) == 0)
    bn_exp.c line  302 - if (wstart == 0) break;
    bn_exp.c line  313 - for (i=1; i<window; i++)
    bn_exp.c line  315 - if (wstart-i < 0) break;
    bn_exp.c line  316 - if (BN_is_bit_set(p,wstart-i))
    bn_exp.c line  328 - for (i=0; i<j; i++)
    bn_exp.c line  342 - if (wstart < 0) break;
    bn_exp.c line  374 - if (bits == 0)
    bn_exp.c line  398 - if (a->neg || BN_ucmp(a,m) >= 0)
    bn_exp.c line  400 - if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line  406 - if (BN_is_zero(aa))
    bn_exp.c line  413 - window = BN_window_bits_for_exponent_size(bits);
    bn_exp.c line  414 - if (window > 1)
    bn_exp.c line  418 - for (i=1; i<j; i++)
    bn_exp.c line  437 - if (BN_is_bit_set(p,wstart) == 0)
    bn_exp.c line  444 - if (wstart == 0) break;
    bn_exp.c line  455 - for (i=1; i<window; i++)
    bn_exp.c line  457 - if (wstart-i < 0) break;
    bn_exp.c line  458 - if (BN_is_bit_set(p,wstart-i))
    bn_exp.c line  470 - for (i=0; i<j; i++)
    bn_exp.c line  484 - if (wstart < 0) break;
    bn_exp.c line  532 - if (bits == 0)
    bn_exp.c line  537 - if (a == 0)
    bn_exp.c line  563 - for (b = bits-2; b >= 0; b--)
    bn_exp.c line  567 - if ((next_w/w) != w) /* overflow */
    bn_exp.c line  576 - if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_exp.c line  587 - if (BN_is_bit_set(p, b))
    bn_exp.c line  590 - if ((next_w/a) != w) /* overflow */
    bn_exp.c line  599 - if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_exp.c line  608 - if (w != 1)
    bn_exp.c line  617 - if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
    bn_exp.c line  649 - if (bits == 0)
    bn_exp.c line  661 - if (BN_is_zero(&(val[0])))
    bn_exp.c line  667 - window = BN_window_bits_for_exponent_size(bits);
    bn_exp.c line  668 - if (window > 1)
    bn_exp.c line  673 - for (i=1; i<j; i++)
    bn_exp.c line  693 - if (BN_is_bit_set(p,wstart) == 0)
    bn_exp.c line  698 - if (wstart == 0) break;
    bn_exp.c line  709 - for (i=1; i<window; i++)
    bn_exp.c line  711 - if (wstart-i < 0) break;
    bn_exp.c line  712 - if (BN_is_bit_set(p,wstart-i))
    bn_exp.c line  724 - for (i=0; i<j; i++)
    bn_exp.c line  738 - if (wstart < 0) break;

    bn_lib.c line  180 - if (l & 0xffffffff00000000L)
    bn_lib.c line  182 - if (l & 0xffff000000000000L)
    bn_lib.c line  184 - if (l & 0xff00000000000000L)
    bn_lib.c line  192 - if (l & 0x0000ff0000000000L)
    bn_lib.c line  226 - if (l & 0xffff0000L)
    bn_lib.c line  228 - if (l & 0xff000000L)
    bn_lib.c line  236 - if (l & 0xff00L)
    bn_lib.c line  252 - if (a->top == 0) return(0);
    bn_lib.c line  263 - if (a == NULL) return;
    bn_lib.c line  264 - if (a->d != NULL)
    bn_lib.c line  267 - if (!(BN_get_flags(a,BN_FLG_STATIC_DATA)))
    bn_lib.c line  272 - if (i)
    bn_lib.c line  278 - if (a == NULL) return;
    bn_lib.c line  279 - if ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))
    bn_lib.c line  282 - if (a->flags & BN_FLG_MALLOCED)
    bn_lib.c line  316 - if (words > (INT_MAX/(4*BN_BITS2)))
    bn_lib.c line  323 - if (BN_get_flags(b,BN_FLG_STATIC_DATA))
    bn_lib.c line  329 - if (A == NULL)
    bn_lib.c line  337 - if (B != NULL)
    bn_lib.c line  339 - for (i=b->top>>2; i>0; i--,A+=4,B+=4)
    bn_lib.c line  370 - for (i=(words - b->top)>>3; i>0; i--,A+=8)
    bn_lib.c line  375 - for (i=(words - b->top)&7; i>0; i--,A++)
    bn_lib.c line  406 - if (words > b->dmax)
    bn_lib.c line  410 - if (a)
    bn_lib.c line  413 - if (r)
    bn_lib.c line  444 - if (words > b->dmax)
    bn_lib.c line  448 - if (a)
    bn_lib.c line  450 - if (b->d)
    bn_lib.c line  465 - if (a == NULL) return NULL;
    bn_lib.c line  473 - if (r == NULL)
    bn_lib.c line  486 - if (a == b) return(a);
    bn_lib.c line  487 - if (bn_wexpand(a,b->top) == NULL) return(NULL);
    bn_lib.c line  492 - for (i=b->top>>2; i>0; i--,A+=4,B+=4)
    bn_lib.c line  511 - if ((a->top == 0) && (a->d != NULL))
    bn_lib.c line  548 - if (a->d != NULL)
    bn_lib.c line  560 - if (n > sizeof(BN_ULONG))
    bn_lib.c line  562 - for (i=a->top-1; i>=0; i--)
    bn_lib.c line  578 - if (bn_expand(a,sizeof(BN_ULONG)*8) == NULL) return(0);
    bn_lib.c line  584 - if (a->d[0] != 0) a->top=1;
    bn_lib.c line  597 - if (a->d[i] != 0) a->top=i+1;
    bn_lib.c line  617 - if (bn_expand(ret,(int)(n+2)*8) == NULL)
    bn_lib.c line  635 - bn_fix_top(ret);
    bn_lib.c line  646 - while (i-- > 0)
    bn_lib.c line  663 - if (i != 0) return(i);
    bn_lib.c line  666 - for (i=a->top-1; i>=0; i--)
    bn_lib.c line  670 - if (t1 != t2)
    bn_lib.c line  682 - if ((a == NULL) || (b == NULL))
    bn_lib.c line  684 - if (a != NULL)
    bn_lib.c line  695 - if (a->neg != b->neg)
    bn_lib.c line  697 - if (a->neg)
    bn_lib.c line  701 - if (a->neg == 0)
    bn_lib.c line  705 - if (a->top > b->top) return(gt);
    bn_lib.c line  706 - if (a->top < b->top) return(lt);
    bn_lib.c line  707 - for (i=a->top-1; i>=0; i--)
    bn_lib.c line  711 - if (t1 > t2) return(gt);
    bn_lib.c line  712 - if (t1 < t2) return(lt);
    bn_lib.c line  723 - if (a->top <= i)
    bn_lib.c line  725 - if (bn_wexpand(a,i+1) == NULL) return(0);
    bn_lib.c line  726 - for(k=a->top; k<i+1; k++)
    bn_lib.c line  741 - if (a->top <= i) return(0);
    bn_lib.c line  744 - bn_fix_top(a);
    bn_lib.c line  752 - if (n < 0) return(0);
    bn_lib.c line  755 - if (a->top <= i) return(0);
    bn_lib.c line  765 - if (w >= a->top) return(0);
    bn_lib.c line  773 - bn_fix_top(a);
    bn_lib.c line  784 - if (aa != bb) return((aa > bb)?1:-1);
    bn_lib.c line  789 - if (aa != bb) return((aa > bb)?1:-1);
    bn_lib.c line  819 - if (a[n+i] != 0)

    bn_mont.c line   83 - if (a == b)
    bn_mont.c line   85 - if (!BN_sqr(tmp,a,ctx)) goto err;
    bn_mont.c line   89 - if (!BN_mul(tmp,a,b,ctx)) goto err;
    bn_mont.c line  112 - if (!BN_copy(r,a)) goto err;
    bn_mont.c line  121 - if ((al == 0) || (nl == 0)) { r->top=0; return(1); }
    bn_mont.c line  124 - if (bn_wexpand(r,max) == NULL) goto err;
    bn_mont.c line  125 - if (bn_wexpand(ret,max) == NULL) goto err;
    bn_mont.c line  134 - for (i=r->top; i<max; i++) /* memset? XXX */
    bn_mont.c line  146 - for (i=0; i<nl; i++)
    bn_mont.c line  166 - if (((nrp[-1]+=v)&BN_MASK2) >= v)
    bn_mont.c line  170 - if (((++nrp[0])&BN_MASK2) != 0) continue;
    bn_mont.c line  171 - if (((+ + nrp[1])&BN_MASK2) != 0) continue;
    bn_mont.c line  172 - for (x=2; (((+ + nrp[x])&BN_MASK2) == 0); x++) ;
    bn_mont.c line  175 - bn_fix_top(r);
    bn_mont.c line  185 - if (r->top < x)
    bn_mont.c line  191 - for (i=0; i<al; i+=4)
    bn_mont.c line  205 - for (; i<al; i++)
    bn_mont.c line  227 - if (BN_ucmp(ret, &(mont->N)) >= 0)
    bn_mont.c line  266 - if (mont->flags & BN_FLG_MALLOCED)
    bn_mont.c line  298 - if (!BN_is_zero(&Ri))
    bn_mont.c line  309 - mont->n0 = (Ri.top > 0) ? Ri.d[0] : 0;
    bn_mont.c line  342 - if (!BN_copy(&(to->RR),&(from->RR))) return NULL;
    bn_mont.c line  343 - if (!BN_copy(&(to->N),&(from->N))) return NULL;
    bn_mont.c line  344 - if (!BN_copy(&(to->Ni),&(from->Ni))) return NULL;
* OpenSSL 0.9.7k
  crypto/rsa/rsa_eay.c -- default definitions of rsa_encrypt functions
  function call to if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx, rsa->_method_mod_n)) goto err;
  crypto/rsa/rsa_lib.c -- Wrapper functions for RSA encryption depending on engine
** RSA_eay_public_encrypt()
   Args: int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding
   Here the plaintext is "from"

   Steps:
   1. Padding "from" flows to "buf"
   2. BN_bin2bn(buf, num, &f)  buf flows to f
   3. bn_mod_exp(...) f(arg2) and rsa->e(arg3) and rsa->n(arg4)
** Flaws found
   ConsElems generated for VOID type maps doesn't match how offset is calculated

   For Example:
    [Source:]   %n39 = getelementptr inbounds %struct.rsa_st, %struct.rsa_st* %44, i32 0, i32 4, !dbg !267
    StructType:
    SourceOffset: 28
      Node0x56888c0 [shape=record,shape=Mrecord,label="{VOID: IE\n}"];
** RSA_eay.c Test
   Tainted:    p,  q
   Untrusted: r1, m1
    rsa_eay.c line 388 - RSA_eay_private_encrypt: NULL check p
    rsa_eay.c line 389 - RSA_eay_private_encrypt: NULL check q
    rsa_eay.c line 526 - RSA_eay_private_decrypt: NULL check p
    rsa_eay.c line 527 - RSA_eay_private_decrypt: NULL check q
    rsa_eay.c line 576 - RSA_eay_private_decrypt: if (r < 0)
    rsa_eay.c line 658 - RSA_eay_public_decrypt: if(r > 42 && 3*8*r >= BN_num_bits(rsa->n))
    rsa_eay.c line 671 - RSA_eay_public_decrypt: if (r < 0)
    -- Below are RSA_eay_mod_exp results
    rsa_eay.c line 701 - if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p, CRYPTO_LOCK_RSA, rsa->p, ctx))
    rsa_eay.c line 704 - if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q, CRYPTO_LOCK_RSA, rsa->q, ctx))
    rsa_eay.c line 709 - if (!BN_mod(&r1,I,rsa->q,ctx))
    rsa_eay.c line 717 - if (!rsa->meth->bn_mod_exp(&m1,&r1,dmq1,rsa->q,ctx, rsa->_method_mod_q))
    rsa_eay.c line 720 - if (!BN_mod(&r1,I,rsa->p,ctx))
    rsa_eay.c line 728 - if (!rsa->meth->bn_mod_exp(r0,&r1,dmp1,rsa->p,ctx, rsa->_method_mod_p))
    rsa_eay.c line 735 - if (!rsa->meth->bn_mod_exp(&m1,&r1,dmq1,rsa->q,ctx, rsa->_method_mod_q))
    rsa_eay.c line 738 - if (!BN_mod(&r1,I,rsa->p,ctx))
    rsa_eay.c line 747 - if (!BN_add(r0,r0,rsa->p))
    rsa_eay.c line 748 - if (!BN_mul(&r1,r0,rsa->q,ctx))
** bn_exp.c test
*** *Commit* 72467763f3 - if ( BN_ucmp(a,m) ) not reported and it should be reported
    Tainted: p, m :: Untrusted: a - No results from OpenSSL versions 0.9.6l 1.0.2f/g
    bn_exp.c line 215 - BN_mod_exp: if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))
    bn_exp.c line 426 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 526 - MOD_EXP_CTIMR_COPY_TO_PREBUF: if (bn_wexpand(b, top) == NULL)
    bn_exp.c line 528 - MOD_EXP_CTIME_COPY_TO_PREBUF: while (b->top < top)
    bn_exp.c line 538 - MOD_EXP_CTIME_COPY_TO_PREBUF: bn_fix_top(b);
    bn_exp.c line 546 - MOD_EXP_CTIME_COPY_FROM_PREBUF: if (bn_wexpand(b, top) == NULL)
    bn_exp.c line 555 - MOD_EXP_CTIME_COPY_FROM_PREBUF: bn_fix_top(b);
*** *Commit* 49a91cc93e  - line 418 correctly reported now
    Tainted: p, m :: Untrusted: a
    bn_exp.c line 215 - BN_mod_exp: if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0)
    bn_exp.c line 279 - BN_mod_exp_recp: if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line 418 - BN_mod_exp_mont: if (a->neg || BN_ucmp(a,m)
    bn_exp.c line 420 - BN_mod_exp_mont: if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line 426 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 441 - BN_mod_exp_mont: if (!BN_mod_mul_montgomery(&(val[i]),&(val[i-1]),d,mont,ctx))
    bn_exp.c line 497 - BN_mod_exp_mont: if (!BN_mod_mul_montgomery(r,r,&(val[wvalue>>1]),mont,ctx))
    bn_exp.c line 526 - MOD_EXP_CTIMR_COPY_TO_PREBUF: if (bn_wexpand(b, top) == NULL)
    bn_exp.c line 528 - MOD_EXP_CTIME_COPY_TO_PREBUF: while (b->top < top)
    bn_exp.c line 538 - MOD_EXP_CTIME_COPY_TO_PREBUF: bn_fix_top(b);
    bn_exp.c line 546 - MOD_EXP_CTIME_COPY_FROM_PREBUF: if (bn_wexpand(b, top) == NULL)
    bn_exp.c line 555 - MOD_EXP_CTIME_COPY_FROM_PREBUF: bn_fix_top(b);
    bn_exp.c line 643 - BN_mod_exp_mont_consttime: if (!BN_mod_mul_montgomery(&(val[i]),&(val[i-1]),d,mont,ctx))
    bn_exp.c line 645 - BN_mod_exp_mont_consttime: if (!BN_mod(am,a,m,ctx))
    bn_exp.c line 900 - BN_mod_exp_simple: if (!BN_nnmod(&(val[0]),a,m,ctx))
*** *Commit* caad0843b7 Tainted/Untrusted :: a, p  - p is private key exponent, a plaintext padded
    bn_exp.c line 142 - BN_exp: if (BN_is_odd(p))

    bn_exp.c line 215 - BN_mod_exp: if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))
    bn_exp.c line 245 - BN_mod_exp: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)

    bn_exp.c line 379 - BN_mod_exp_mont: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0) - maybe non-vulnerability
    bn_exp.c line 426 - BN_mod_exp_mont: if (BN_is_zero(aa)) - maybe non-vulnerability

    bn_exp.c line 538 - MOD_EXP_CTIME_COPY_TO_PREBUF: bn_fix_top(b) - constant time called from BN_mod_exp_mont
    bn_exp.c line 555 - MOD_EXP_CTIME_COPY_FROM_PREBUF: bn_fix_top(b) - constant time called from BN_mod_exp_mont
    bn_exp.c line 746 - BN_mod_exp_mont_word:if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0) - maybe non-vulnerability?
    bn_exp.c line 770 - BN_mod_exp_mont_word: if (a == 0) - if a is zeros rr = zero

    BN_mod_exp_mont_word - calculating r * w  potential for timing attack
    bn_exp.c line 800 - if ((next_w/w) != w)
    bn_exp.c line 804 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 809 - if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 823 - if ((next_w/a) != w)
    bn_exp.c line 827 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 832 - if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 841 - if (w != 1)
    bn_exp.c line 845 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 850 - if (!BN_MOD_MUL_WORD(r, w, m))

    bn_exp.c line 880 - if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
*** *Commit* caad0843b7 Tainted/Untrusted: a, m, p
    bn_exp.c line 142 - BN_exp: if (BN_is_odd(p))
    bn_exp.c line 212 - BN_mod_exp: if (BN_is_odd(m))
    bn_exp.c line 215 - BN_mod_exp: if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))
    bn_exp.c line 245 - BN_mod_exp: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 379 - BN_mod_exp_mont: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 388 - BN_mod_exp_mont: if (!(m->d[0] & 1))
    bn_exp.c line 426 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 538 - MOD_EXP_CTIME_COPY_TO_PREBUF: bn_fix_top(b)
    bn_exp.c line 555 - MOD_EXP_CTIME_COPY_FROM_PREBUF: bn_fix_top(b)
    bn_exp.c line 590 - BN_mod_exp_mont_consttime: if (!(m->d[0] & 1))
    bn_exp.c line 746 - BN_mod_exp_mont_word: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 756 - BN_mod_exp_mont_word: if (m->top == 0 || !(m->d[0] & 1))
    bn_exp.c line 770 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 800 - BN_mod_exp_mont_word: if ((next_w/w) != w)
    bn_exp.c line 804 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 809 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 823 - BN_mod_exp_mont_word: if ((next_w/a) != w)
    bn_exp.c line 827 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 832 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 841 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 845 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 850 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 880 - BN_mod_exp_simple: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
*** *Commit* caad0843b7 Tainted: p, m :: Untrusted: a
    bn_exp.c line 770 - if (a == 0)
    bn_exp.c line 800 - if ((next_w/w) != w)
    bn_exp.c line 804 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 809 - if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 823 - if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 827 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 832 - if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 841 - if (w != 1)
    bn_exp.c line 845 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 850 - if (!BN_MOD_MUL_WORD(r, w, m))
*** *commit* 3798197c41 Tainted/Untrusted: a, p
    bn_exp.c line 125 - BN_exp: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 133 - BN_exp: if ((r == a) || (r == p))
    bn_exp.c line 142 - BN_exp: if (BN_is_odd(p))
    bn_exp.c line 146 - BN_exp: for (i=1; i<bits; i++)
    bn_exp.c line 149 - BN_exp: if (BN_is_bit_set(p,i))

    bn_exp.c line 215 - BN_mod_exp: if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))

    bn_exp.c line 245 - BN_mod_exp_recp: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 254 - BN_mod_exp_recp: if (bits == 0)
    bn_exp.c line 279 - BN_mod_exp_recp: if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line 286 - BN_mod_exp_recp: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 287 - BN_mod_exp_recp: if (window > 1)
    bn_exp.c line 292 - BN_mod_exp_recp: for (i=1; i<j; i++)
    bn_exp.c line 312 - BN_mod_exp_recp: if (BN_is_bit_set(p,wstart) == 0)
    bn_exp.c line 317 - BN_mod_exp_recp: if (wstart == 0)
    bn_exp.c line 328 - BN_mod_exp_recp: for (i=1; i<window; i++)
    bn_exp.c line 330 - BN_mod_exp_recp: if (wstart-i < 0)
    bn_exp.c line 331 - BN_mod_exp_recp: if (BN_is_bit_set(p,wstart-i))
    bn_exp.c line 343 - BN_mod_exp_recp: for (i=0; i<j; i++)
    bn_exp.c line 357 - BN_mod_exp_recp: if (wstart < 0)

    bn_exp.c line 379 - BN_mod_exp_mont: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 394 - BN_mod_exp_mont: if (bits == 0)
    bn_exp.c line 418 - BN_mod_exp_mont: if (a->neg || BN_ucmp(a,m) >= 0)
    bn_exp.c line 420 - BN_mod_exp_mont: if (!BN_nnmod(&(val[0]),a,m,ctx))
    bn_exp.c line 426 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 431 - BN_mod_exp_mont: if (!BN_to_montgomery(&(val[0]),aa,mont,ctx))
    bn_exp.c line 433 - BN_mod_exp_mont: window = BN_window_bits_for_exponent_size(bits)
    NOTE: Why is this reported
      #define BN_window_bits_for_exponent_size(b) \
          ((b) > 671 ? 6 : \
          (b) > 239 ? 5 : \
          (b) >  79 ? 4 : \
          (b) >  23 ? 3 : 1)
    bn_exp.c line 434 - BN_mod_exp_mont: if (window > 1)
    bn_exp.c line 438 - BN_mod_exp_mont: for (i=1; i<j; i++)
    bn_exp.c line 457 - BN_mod_exp_mont: if (BN_is_bit_set(p,wstart) == 0)
    bn_exp.c line 464 - BN_mod_exp_mont: if (wstart == 0)
    bn_exp.c line 475 - BN_mod_exp_mont: for (i=1; i<window; i++)
    bn_exp.c line 477 - BN_mod_exp_mont: if (wstart-i < 0)
    bn_exp.c line 478 - BN_mod_exp_mont: if (BN_is_bit_set(p,wstart-i))
    bn_exp.c line 490 - BN_mod_exp_mont: for (i=0; i<j; i++)
    bn_exp.c line 504 - BN_mod_exp_mont: if (wstart < 0)

    bn_exp.c line 538 - MOD_EXP_CTIME_COPY_TO_PREBUF: bn_fix_top(b)
    bn_exp.c line 555 - MOD_EXP_CTIME_COPY_FROM_PREBUF: bn_fix_top(b)

    bn_exp.c line 596 - BN_mod_exp_mont_consttime: if (bits == 0)
    bn_exp.c line 619 - BN_mod_exp_mont_consttime: window = BN_window_bits_for_ctime_exponent_size(bits)
    bn_exp.c line 626 - BN_mod_exp_mont_consttime: if ((powerbufFree=(unsigned char*)OPENSSL_malloc(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)
    bn_exp.c line 643 - BN_mod_exp_mont_consttime: if (a->neg || BN_ucmp(a,m)
    bn_exp.c line 645 - BN_mod_exp_mont_consttime: if (!BN_mod(am,a,m,ctx))
    bn_exp.c line 651 - BN_mod_exp_mont_consttime: if (!BN_to_montgomery(am,aa,mont,ctx))
    bn_exp.c line 660 - BN_mod_exp_mont_consttime: if (window > 1)
    bn_exp.c line 662 - BN_mod_exp_mont_consttime: for (i=2; i<numPowers; i++)
    bn_exp.c line 688 - BN_mod_exp_mont_consttime: while (idx >= 0)
    bn_exp.c line 693 - BN_mod_exp_mont_consttime: for (i=0; i<window; i++,idx--)
    bn_exp.c line 711 - BN_mod_exp_mont_consttime: if (powerbuf!=NULL)

    bn_exp.c line 746 - BN_mod_exp_mont_word: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 765 - BN_mod_exp_mont_word: if (bits == 0)
    bn_exp.c line 770 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 796 - BN_mod_exp_mont_word: for (b = bits-2; b >= 0; b--)
    bn_exp.c line 800 - BN_mod_exp_mont_word: if ((next_w/w) != w)
    bn_exp.c line 804 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 809 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 820 - BN_mod_exp_mont_word: if (BN_is_bit_set(p, b))
    bn_exp.c line 823 - BN_mod_exp_mont_word: if ((next_w/a) != w)
    bn_exp.c line 827 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 832 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 841 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 845 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 850 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))

    bn_exp.c line 880 - BN_mod_exp_simple: if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
    bn_exp.c line 889 - BN_mod_exp_simple: if (bits == 0)
    bn_exp.c line 907 - BN_mod_exp_simple: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 908 - BN_mod_exp_simple: if (window > 1)
    bn_exp.c line 913 - BN_mod_exp_simple: for (i=1; i<j; i++)
    bn_exp.c line 933 - BN_mod_exp_simple: if (BN_is_bit_set(p,wstart) == 0)
    bn_exp.c line 938 - BN_mod_exp_simple: if (wstart == 0)
    bn_exp.c line 949 - BN_mod_exp_simple: for (i=1; i<window; i++)
    bn_exp.c line 951 - BN_mod_exp_simple: if (wstart-i < 0)
    bn_exp.c line 952 - BN_mod_exp_simple: if (BN_is_bit_set(p,wstart-i))
    bn_exp.c line 964 - BN_mod_exp_simple: for (i=0; i<j; i++)
    bn_exp.c line 978 - BN_mod_exp_simple: if (wstart < 0)
*** *Commit* 3798198c41 BN_mod_exp_Recp only Tainted/Untrusted: a/p
    bn_test.c line 16
    bn_test.c line 25
    bn_test.c line 57
    bn_test.c line 58
    bn_test.c line 63
    bn_test.c line 83
    bn_test.c line 88
    bn_test.c line 99
    bn_test.c line 101
    bn_test.c line 102
    bn_test.c line 114
    bn_test.c line 128
* OpenSSL 1.0.2n
** bn_exp.c test
*** Commit *d72a4c71d7* Tainted/Untrusted: a, p
    bn_exp.c line 148 - BN_exp: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 149 - BN_exp: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 156 - BN_exp: if ((r == a) || (r == p))
    bn_exp.c line 164 - BN_exp: if (BN_copy(v, a) == NULL)
    bn_exp.c line 168 - BN_exp: if (BN_is_odd(p))
    bn_exp.c line 169 - BN_exp: if (BN_copy(rr, a) == NULL)
    bn_exp.c line 176 - BN_exp: for (i = 1; i < bits; i++)
    bn_exp.c line 179 - BN_exp: if (BN_is_bit_set(p, i))


    bn_exp.c line 248 - BN_mod_exp: if (a->top == 1 && !a->neg
    bn_exp.c line 249 - BN_mod_exp: && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)
    bn_exp.c line 250 - BN_mod_exp: && (BN_get_flags(a, BN_FLG_CONSTTIME) == 0)
    bn_exp.c line 251 - BN_mod_exp: && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0))

    bn_exp.c line 284 - BN_mod_exp_recp: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 285 - BN_mod_exp_recp: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 292 - BN_mod_exp_recp: if (bits == 0)
    bn_exp.c line 322 - BN_mod_exp_recp: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 330 - BN_mod_exp_recp: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 331 - BN_mod_exp_recp: if (window > 1)
    bn_exp.c line 335 - BN_mod_exp_recp: for (i = 1; i < j; i++)
    bn_exp.c line 353 - BN_mod_exp_recp: if (BN_is_bit_set(p, wstart) == 0)
    bn_exp.c line 357 - BN_mod_exp_recp: if (wstart == 0)
    bn_exp.c line 370 - BN_mod_exp_recp: for (i = 1; i < window; i++)
    bn_exp.c line 371 - BN_mod_exp_recp: if (wstart - i < 0)
    bn_exp.c line 373 - BN_mod_exp_recp: if (BN_is_bit_set(p, wstart - i))
    bn_exp.c line 384 - BN_mod_exp_recp: for (i = 0; i < j; i++)
    bn_exp.c line 397 - BN_mod_exp_recp: if (wstart < 0)

    bn_exp.c line 420 - BN_mod_exp_mont: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 421 - BN_mod_exp_mont: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 434 - BN_mod_exp_mont: if (bits == 0)
    bn_exp.c line 465 - BN_mod_exp_mont: if (a->neg || BN_ucmp(a, m) >= 0)
    bn_exp.c line 466 - BN_mod_exp_mont: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 471 - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 476 - BN_mod_exp_mont: if (!BN_to_montgomery(val[0], aa, mont, ctx))
    bn_exp.c line 479 - BN_mod_exp_mont: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 480 - BN_mod_exp_mont: if (window > 1)
    bn_exp.c line 484 - BN_mod_exp_mont: for (i = 1; i < j; i++)
    bn_exp.c line 500 - BN_mod_exp_mont: if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1)))
    bn_exp.c line 501 - BN_mod_exp_mont: if (bn_wexpand(r, j) == NULL)
    bn_exp.c line 505 - BN_mod_exp_mont: for (i = 1; i < j; i++)
    bn_exp.c line 512 - BN_mod_exp_mont: bn_correct_top(r)
    bn_exp.c line 518 - BN_mod_exp_mont: if (BN_is_bit_set(p, wstart) == 0)
    bn_exp.c line 523 - BN_mod_exp_mont: if (wstart == 0)
    bn_exp.c line 536 - BN_mod_exp_mont: for (i = 1; i < window; i++)
    bn_exp.c line 537 - BN_mod_exp_mont: if (wstart - i < 0)
    bn_exp.c line 539 - BN_mod_exp_mont: if (BN_is_bit_set(p, wstart - i))
    bn_exp.c line 550 - BN_mod_exp_mont: for (i = 0; i < j; i++)
    bn_exp.c line 563 - BN_mod_exp_mont: if (wstart < 0)

    bn_exp.c line 645 - MOD_EXP_CTIME_COPY_FROM_PREBUF: if (window <= 3)
    bn_exp.c line 646 - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (i = 0; i < top; i++, table += width)
    bn_exp.c line 649 - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (j = 0; j < width; j++)
    bn_exp.c line 668 - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (i = 0; i < top; i++, table += width)
    bn_exp.c line 671 - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (j = 0; j < xstride; j++)
    bn_exp.c line 684 - MOD_EXP_CTIME_COPY_FROM_PREBUF: bn_correct_top(b)

    bn_exp.c line 731  - BN_mod_exp_mont_consttime: if (bits == 0)
    bn_exp.c line 787  - BN_mod_exp_mont_consttime: window = BN_window_bits_for_ctime_exponent_size(bits)
    bn_exp.c line 811  - BN_mod_exp_mont_consttime: ((2 * top) > numPowers ? (2 * top) : numPowers));
    bn_exp.c line 814  - BN_mod_exp_mont_consttime: if (powerbufLen < 3072)
    bn_exp.c line 819  - BN_mod_exp_mont_consttime: malloc
    bn_exp.c line 829  - BN_mod_exp_mont_consttime: if (powerbufLen < 3072)
    bn_exp.c line 846  - BN_mod_exp_mont_consttime: for (i = 1; i < top; i++)
    bn_exp.c line 855  - BN_mod_exp_mont_consttime: if (a->neg || BN_ucmp(a, m) >= 0)
    bn_exp.c line 856  - BN_mod_exp_mont_consttime: if (!BN_mod(&am, a, m, ctx))
    bn_exp.c line 860  - BN_mod_exp_mont_consttime: else if (!BN_to_montgomery(&am, a, mont, ctx))
    bn_exp.c line 1126 - BN_mod_exp_mont_consttime: if (window > 1)
    bn_exp.c line 1132 - BN_mod_exp_mont_consttime: for (i = 3; i < numPowers; i++)
    bn_exp.c line 1143 - BN_mod_exp_mont_consttime: for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
    bn_exp.c line 1153 - BN_mod_exp_mont_consttime: while (bits >= 0)
    bn_exp.c line 1157 - BN_mod_exp_mont_consttime: for (i = 0; i < window; i++, bits--)
    bn_exp.c line 1192 - BN_mod_exp_mont_consttime: if (powerbuf != NULL)
    bn_exp.c line 1194 - BN_mod_exp_mont_consttime: if (powerbufFree)

    bn_exp.c line 1228 - BN_mod_exp_mont_word: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 1245 - BN_mod_exp_mont_word: if (bits == 0)
    bn_exp.c line 1255 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 1283 - BN_mod_exp_mont_word: for (b = bits - 2; b >= 0; b--)
    bn_exp.c line 1286 - BN_mod_exp_mont_word: if ((next_w / w) != w)
    bn_exp.c line 1288 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1292 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 1304 - BN_mod_exp_mont_word: if (BN_is_bit_set(p, b))
    bn_exp.c line 1306 - BN_mod_exp_mont_word: if ((next_w / a) != w)
    bn_exp.c line 1308 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1312 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 1322 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 1324 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1328 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))

    bn_exp.c line 1360 - BN_mod_exp_simple: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 1361 - BN_mod_exp_simple: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 1368 - BN_mod_exp_simple: if (bits == 0)
    bn_exp.c line 1385 - BN_mod_exp_simple: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 1393 - BN_mod_exp_simple: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 1394 - BN_mod_exp_simple: if (window > 1)
    bn_exp.c line 1398 - BN_mod_exp_simple: for (i = 1; i < j; i++)
    bn_exp.c line 1416 - BN_mod_exp_simple: if (BN_is_bit_set(p, wstart) == 0)
    bn_exp.c line 1420 - BN_mod_exp_simple: if (wstart == 0)
    bn_exp.c line 1433 - BN_mod_exp_simple: for (i = 1; i < window; i++)
    bn_exp.c line 1434 - BN_mod_exp_simple: if (wstart - i < 0)
    bn_exp.c line 1436 - BN_mod_exp_simple: if (BN_is_bit_set(p, wstart - i))
    bn_exp.c line 1447 - BN_mod_exp_simple: for (i = 0; i < j; i++)
    bn_exp.c line 1460 - BN_mod_exp_simple: if (wstart < 0)
* OpenSSL 1.1.0g
** bn_exp.c test
*** Commit *319237301b* Tainted/Untrusted: a, p
    bn_exp.c line 146  - BN_mod_exp: if (a->top == 1 && !a->neg
    bn_exp.c line 147  - BN_mod_exp: && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)
    bn_exp.c line 149  - BN_mod_exp: && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0))
    bn_exp.c line 183  - BN_mod_exp_recp: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 220  - BN_mod_exp_recp: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 319  - BN_mod_exp_mont: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 363  - BN_mod_exp_mont: if (a->neg || BN_ucmp(a, m) >= 0)
    bn_exp.c line 364  - BN_mod_exp_mont: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 369  - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 374  - BN_mod_exp_mont: if (!BN_to_montgomery(val[0], aa, mont, ctx))
    bn_exp.c line 760  - BN_mod_exp_mont_consttime: if (a->neg || BN_ucmp(a, m) >= 0)
    bn_exp.c line 761  - BN_mod_exp_mont_consttime: if (!BN_mod(&am, a, m, ctx))
    bn_exp.c line 765  - BN_mod_exp_mont_consttime: else if (!BN_to_montgomery(&am, a, mont, ctx))
    bn_exp.c line 1159 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 1190 - BN_mod_exp_mont_word: if ((next_w / w) != w)
    bn_exp.c line 1192 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1196 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 1210 - BN_mod_exp_mont_word: if ((next_w / a) != w)
    bn_exp.c line 1212 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1216 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 1226 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 1228 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1232 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
*** Commit *319237301b* Tainted/Untrusted: a, p :: Also linked with bn_lib.c becuase of function definitions
    bn_exp.c line 46   - BN_exp: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 47   - BN_exp: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 54   - BN_exp: if ((r == a) || (r == p))
    bn_exp.c line 62   - BN_exp: if (BN_copy(v, a) == NULL)
    bn_exp.c line 66   - BN_exp: if (BN_is_odd(p))
    bn_exp.c line 67   - BN_exp: if (BN_copy(rr, a) == NULL)
    bn_exp.c line 74   - BN_exp: for (i = 1; i < bits; i++)
    bn_exp.c line 77   - BN_exp: if (BN_is_bit_set(p, i))
    bn_exp.c line 82   - BN_exp: if (r != rr && BN_copy(r, rr) == NULL) // defined in bn_lib

    bn_exp.c line 144  - BN_mod_exp: if (BN_is_odd(m))
    bn_exp.c line 146  - BN_mod_exp: if (a->top == 1 && !a->neg
    bn_exp.c line 147  - BN_mod_exp: && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)
    bn_exp.c line 148  - BN_mod_exp: && (BN_get_flags(a, BN_FLG_CONSTTIME) == 0)
    bn_exp.c line 149  - BN_mod_exp: && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0))

    bn_exp.c line 181  - BN_mod_exp_recp: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 182  - BN_mod_exp_recp: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 183  - BN_mod_exp_recp: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 190  - BN_mod_exp_recp: if (bits == 0)
    bn_exp.c line 192  - BN_mod_exp_recp: if (BN_is_one(m))
    bn_exp.c line 208  - BN_mod_exp_recp: if (m->neg)
    bn_exp.c line 210  - BN_mod_exp_recp: if (!BN_copy(aa, m))
    bn_exp.c line 220  - BN_mod_exp_recp: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 222  - BN_mod_exp_recp: if (BN_is_zero(val[0]))
    bn_exp.c line 228  - BN_mod_exp_recp: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 229  - BN_mod_exp_recp: if (window > 1)
    bn_exp.c line 233  - BN_mod_exp_recp: for (i = 1; i < j; i++)
    bn_exp.c line 251  - BN_mod_exp_recp: if (BN_is_bit_set(p, wstart) == 0)
    bn_exp.c line 255  - BN_mod_exp_recp: if (wstart == 0)
    bn_exp.c line 268  - BN_mod_exp_recp: for (i = 1; i < window; i++)
    bn_exp.c line 269  - BN_mod_exp_recp: if (wstart - i < 0)
    bn_exp.c line 271  - BN_mod_exp_recp: if (BN_is_bit_set(p, wstart - i))
    bn_exp.c line 282  - BN_mod_exp_recp: for (i = 0; i < j; i++)  ==Sliding L-R Equivalent OpenSSL==
    bn_exp.c line 295  - BN_mod_exp_recp: if (wstart < 0)

    bn_exp.c line 317  - BN_mod_exp_mont: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 318  - BN_mod_exp_mont: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 319  - BN_mod_exp_mont: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 327  - BN_mod_exp_mont: if (!BN_is_odd(m))
    bn_exp.c line 332  - BN_mod_exp_mont: if (bits == 0)
    bn_exp.c line 334  - BN_mod_exp_mont: if (BN_is_one(m))
    bn_exp.c line 363  - BN_mod_exp_mont: if (a->neg || BN_ucmp(a, m) >= 0)
    bn_exp.c line 364  - BN_mod_exp_mont: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 369  - BN_mod_exp_mont: if (BN_is_zero(aa))
    bn_exp.c line 374  - BN_mod_exp_mont: if (!BN_to_montgomery(val[0], aa, mont, ctx))
    bn_exp.c line 377  - BN_mod_exp_mont: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 378  - BN_mod_exp_mont: if (window > 1)
    bn_exp.c line 382  - BN_mod_exp_mont: for (i = 1; i < j; i++)
    bn_exp.c line 398  - BN_mod_exp_mont: if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1)))
    bn_exp.c line 399  - BN_mod_exp_mont: if (bn_wexpand(r, j) == NULL)
    bn_exp.c line 403  - BN_mod_exp_mont: for (i = 1; i < j; i++)
    bn_exp.c line 413  - BN_mod_exp_mont: if (!BN_to_montgomery(r, BN_value_one(), mont, ctx)
    bn_exp.c line 416  - BN_mod_exp_mont: if (BN_is_bit_set(p, wstart) == 0)
    bn_exp.c line 421  - BN_mod_exp_mont: if (wstart == 0)
    bn_exp.c line 434  - BN_mod_exp_mont: for (i = 1; i < window; i++)
    bn_exp.c line 435  - BN_mod_exp_mont: if (wstart - i < 0)
    bn_exp.c line 437  - BN_mod_exp_mont: if (BN_is_bit_set(p, wstart - i))
    bn_exp.c line 448  - BN_mod_exp_mont: for (i = 0; i < j; i++)  ==Sliding L-R Equivalent OpenSSL==
    bn_exp.c line 461  - BN_mod_exp_mont: if (wstart < 0)

    bn_exp.c line 522  - MOD_EXP_CTIME_COPY_TO_PREBUF: if (top > b->top)
    bn_exp.c line 525  - MOD_EXP_CTIME_COPY_TO_PREBUF: for (i = 0, j = idx; i < top; i++, j += width)

    bn_exp.c line 548  - MOD_EXP_CTIME_COPY_FROM_PREBUF: if (bn_wexpand(b, top) == NULL)
    bn_exp.c line 551  - MOD_EXP_CTIME_COPY_FROM_PREBUF: if (window <= 3)
    bn_exp.c line 552  - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (i = 0; i < top; i++, table += width)
    bn_exp.c line 555  - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (j = 0; j < width; j++)
    bn_exp.c line 574  - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (i = 0; i < top; i++, table + = width)
    bn_exp.c line 577  - MOD_EXP_CTIME_COPY_FROM_PREBUF: for (j = 0; j < xstride; j++)

    bn_exp.c line 629  - BN_mod_exp_mont_consttime: if (!BN_is_odd(m))
    bn_exp.c line 637  - BN_mod_exp_mont_consttime: if (bits == 0)
    bn_exp.c line 639  - BN_mod_exp_mont_consttime: if (BN_is_one(m))
    bn_exp.c line 693  - BN_mod_exp_mont_consttime: window = BN_window_bits_for_ctime_exponent_size(bits)
    bn_exp.c line 717  - BN_mod_exp_mont_consttime: ((2 * top) > numPowers ? (2 * top) : numPowers));
    bn_exp.c line 720  - BN_mod_exp_mont_consttime: if (powerbufLen < 3072)
    bn_exp.c line 725  - BN_mod_exp_mont_consttime: if ((powerbufFree = OPENSSL_malloc(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)
    bn_exp.c line 734  - BN_mod_exp_mont_consttime: if (powerbufLen < 3072)
    bn_exp.c line 748  - BN_mod_exp_mont_consttime: if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1)))
    bn_exp.c line 751  - BN_mod_exp_mont_consttime: for (i = 1; i < top; i++)
    bn_exp.c line 756  - BN_mod_exp_mont_consttime: if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
    bn_exp.c line 760  - BN_mod_exp_mont_consttime: if (a->neg || BN_ucmp(a, m) >= 0)
    bn_exp.c line 761  - BN_mod_exp_mont_consttime: if (!BN_mod(&am, a, m, ctx))
    bn_exp.c line 763  - BN_mod_exp_mont_consttime: if (!BN_to_montgomery(&am, &am, mont, ctx))
    bn_exp.c line 765  - BN_mod_exp_mont_consttime: else if (!BN_to_montgomery(&am, a, mont, ctx))
    bn_exp.c line 1031 - BN_mod_exp_mont_consttime: if (window > 1)
    bn_exp.c line 1037 - BN_mod_exp_mont_consttime: for (i = 3; i < numPowers; i++)
    bn_exp.c line 1048 - BN_mod_exp_mont_consttime: for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
    bn_exp.c line 1058 - BN_mod_exp_mont_consttime: while (bits >= 0)
    bn_exp.c line 1062 - BN_mod_exp_mont_consttime: for (i = 0; i < window; i++, bits--) ==Sliding L-R Result in OpenSSL== *Constant Time (No Vulnerability)*
    bn_exp.c line 1097 - BN_mod_exp_mont_consttime: if (powerbuf != NULL)

    bn_exp.c line 1131 - BN_mod_exp_mont_word: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 1132 - BN_mod_exp_mont_word: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 1141 - BN_mod_exp_mont_word: if (!BN_is_odd(m))
    bn_exp.c line 1145 - BN_mod_exp_mont_word: if (m->top == 1)
    bn_exp.c line 1149 - BN_mod_exp_mont_word: if (bits == 0)
    bn_exp.c line 1151 - BN_mod_exp_mont_word: if (BN_is_one(m))
    bn_exp.c line 1159 - BN_mod_exp_mont_word: if (a == 0)
    bn_exp.c line 1187 - BN_mod_exp_mont_word: for (b = bits - 2; b >= 0; b--)
    bn_exp.c line 1190 - BN_mod_exp_mont_word: if ((next_w / w) != w)
    bn_exp.c line 1192 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1196 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 1208 - BN_mod_exp_mont_word: if (BN_is_bit_set(p, b))
    bn_exp.c line 1210 - BN_mod_exp_mont_word: if ((next_w / a) != w)
    bn_exp.c line 1212 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1216 - BN_mod_exp_mont_word: if (!BN_MOD_MUL_WORD(r, w, m))
    bn_exp.c line 1226 - BN_mod_exp_mont_word: if (w != 1)
    bn_exp.c line 1228 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
    bn_exp.c line 1232 - BN_mod_exp_mont_word: if (!BN_TO_MONTGOMERY_WORD(r, w, mont))

    bn_exp.c line 1263 - BN_mod_exp_simple: if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 1264 - BN_mod_exp_simple: || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
    bn_exp.c line 1265 - BN_mod_exp_simple: || BN_get_flags(m, BN_FLG_CONSTTIME) != 0)
    bn_exp.c line 1272 - BN_mod_exp_simple: if (bits == 0)
    bn_exp.c line 1274 - BN_mod_exp_simple: if (BN_is_one(m))
    bn_exp.c line 1289 - BN_mod_exp_simple: if (!BN_nnmod(val[0], a, m, ctx))
    bn_exp.c line 1291 - BN_mod_exp_simple: if (BN_is_zero(val[0]))
    bn_exp.c line 1297 - BN_mod_exp_simple: window = BN_window_bits_for_exponent_size(bits)
    bn_exp.c line 1298 - BN_mod_exp_simple: if (window > 1)
    bn_exp.c line 1302 - BN_mod_exp_simple: for (i = 1; i < j; i++)
    bn_exp.c line 1320 - BN_mod_exp_simple: if (BN_is_bit_set(p, wstart) == 0)
    bn_exp.c line 1324 - BN_mod_exp_simple: if (wstart == 0)
    bn_exp.c line 1337 - BN_mod_exp_simple: for (i = 1; i < window; i++)
    bn_exp.c line 1338 - BN_mod_exp_simple: if (wstart - i < 0)
    bn_exp.c line 1340 - BN_mod_exp_simple: if (BN_is_bit_set(p, wstart - i))
    bn_exp.c line 1351 - BN_mod_exp_simple: for (i = 0; i < j; i++)
    bn_exp.c line 1364 - BN_mod_exp_simple: if (wstart < 0)
*** Commit *e54a398*
    Tainted/Untrusted: a, p
    Whitelist: 
    
    134 Results 
    #+BEGIN_SRC c
       bn_exp.c line   46 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0      // Undefined-signature, `p` sensitive
       bn_exp.c line   47 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0) {    // Undefined-signature, `a` sensitive
       bn_exp.c line   54 - if ((r == a) || (r == p)) // Branch equality check on sensitive `a` and `p`
       bn_exp.c line   62 - if (BN_copy(v, a) == NULL) // Undefined Signature BN_copy, `a` taints `v` and retval
       bn_exp.c line   66 - if (BN_is_odd(p)) { // Undefined Signature BN_is_odd, `p` taints retval
       bn_exp.c line   67 - if (BN_copy(rr, a) == NULL) // Undefined Signature BN_copy, `a` taints retval and rr
       bn_exp.c line   74 - for (i = 1; i < bits; i++) { // Repeated Branch + Constant time loop over length of `p` 
       bn_exp.c line   77 - if (BN_is_bit_set(p, i)) { // Branch in loop + Undefined signature `p` taints `i` and retval
       bn_exp.c line  144 - if (BN_is_odd(m)) { //Undefined Signature `m` taints retval
       bn_exp.c line  146 - if (a->top == 1 && !a->neg
       bn_exp.c line  147 - && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0) // Undefined signature `p` taints retval
       bn_exp.c line  148 - && (BN_get_flags(a, BN_FLG_CONSTTIME) == 0) // Undefined signature `a` taints retval
       bn_exp.c line  149 - && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0)) { // Undefined signature `m` taints retval
       bn_exp.c line  181 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 // Undefined signature `p` taints retval
       bn_exp.c line  182 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 // Undefined signature `a` taints retval
       bn_exp.c line  183 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) { // Undefined signature `m` taints retval
       bn_exp.c line  190 - if (bits == 0) { //Branch on length of `p`
       bn_exp.c line  192 - if (BN_is_one(m)) { // Branch on value of `m` 
       bn_exp.c line  208 - if (m->neg) { // Branch on `m` data
       bn_exp.c line  210 - if (!BN_copy(aa, m)) // Undefined Signature BN_copy  `m` taints  `aa` and retval
       bn_exp.c line  213 - if (BN_RECP_CTX_set(&recp, aa, ctx) <= 0) // Undefined Signature BN_RECP_CTX_set `aa` taint arguments and retval
       bn_exp.c line  216 - if (BN_RECP_CTX_set(&recp, m, ctx) <= 0) // Undefined Signature BN_RECP_CTX_set `m` taint arguments and retval
       bn_exp.c line  220 - if (!BN_nnmod(val[0], a, m, ctx)) // Undefined Signature BN-nnmod `a` taints all agurments and retval
       bn_exp.c line  228 - window = BN_window_bits_for_exponent_size(bits); // Branch on bits which is tainted by `p`
       bn_exp.c line  229 - if (window > 1) { // Branch on tainted `window`
       bn_exp.c line  230 - if (!BN_mod_mul_reciprocal(aa, val[0], val[0], &recp, ctx)) //Undefined signature
       bn_exp.c line  233 - for (i = 1; i < j; i++) { // Repeated Branch on j computed  from window 
       bn_exp.c line  234 - if (((val[i] = BN_CTX_get(ctx)) == NULL) || //Undefined Signature, `ctx` taints all
       bn_exp.c line  251 - if (BN_is_bit_set(p, wstart) == 0) { //Repeated Branch + Undefined signature, `p` taints all
       bn_exp.c line  255 - if (wstart == 0) // Repeated Branch on tainted data
       bn_exp.c line  268 - for (i = 1; i < window; i++) { // Repeated Branch + NOT Constant time loop `window` tainted
      = bn_exp.c line  269 - if (wstart - i < 0) // repeated branch in loop, causes break in for(i=1; i<window;i++)
      = bn_exp.c line  271 - if (BN_is_bit_set(p, wstart - i)) { // repeated branch sets wend value
      = bn_exp.c line  282 - for (i = 0; i < j; i++) { // Nested Loop, not constant time `j` value derived from `p`
       bn_exp.c line  295 - if (wstart < 0) // Repeated branch breaks for(;;) loop
       bn_exp.c line  317 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 // Undefined signature `p` taints retval
       bn_exp.c line  318 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 // Undefined signature `a` taints retval
       bn_exp.c line  319 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) { // Undefined signature `m` taints retval
       bn_exp.c line  327 - if (!BN_is_odd(m)) { //Undefined signature `m` taints all
       bn_exp.c line  332 - if (bits == 0) { // Branch on length of `p`
       bn_exp.c line  334 - if (BN_is_one(m)) { // Branch on value of `m`
       bn_exp.c line  359 - if (!BN_MONT_CTX_set(mont, m, ctx)) // Undefined signature `m` taints all
       bn_exp.c line  363 - if (a->neg || BN_ucmp(a, m) >= 0) { // Branch on `a` and `m`
       bn_exp.c line  364 - if (!BN_nnmod(val[0], a, m, ctx)) // Undefined signature `a` taints  all
       bn_exp.c line  369 - if (BN_is_zero(aa)) { // Undefined Signature `aa` taints all
       bn_exp.c line  374 - if (!BN_to_montgomery(val[0], aa, mont, ctx)) // Undefined signature `aa` taints all
       bn_exp.c line  377 - window = BN_window_bits_for_exponent_size(bits); // Branch on bits based on `p`
       bn_exp.c line  378 - if (window > 1) { // Branch on tainted
       bn_exp.c line  379 - if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx)) // Undefined signature `val[0]` taints all
       bn_exp.c line  382 - for (i = 1; i < j; i++) { // Repeated Branch + Constant time loop `j` tainted
       bn_exp.c line  383 - if (((val[i] = BN_CTX_get(ctx)) == NULL) || // Undefined signature UNSURE taints all
       bn_exp.c line  398 - if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) { // Branch on data of `m`
       bn_exp.c line  399 - if (bn_wexpand(r, j) == NULL) // Undefined signature `j` taints all
       bn_exp.c line  403 - for (i = 1; i < j; i++) // Repeated branch, UNSURE of constant time due to bn_wexpand
       bn_exp.c line  413 - if (!BN_to_montgomery(r, BN_value_one(), mont, ctx)) // Undefined signature UNSURE taints all
       bn_exp.c line  416 - if (BN_is_bit_set(p, wstart) == 0) { // Undefined signature, `p` taints all
       bn_exp.c line  418 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) // Undefined signature `r` or `mont` taints all
       bn_exp.c line  421 - if (wstart == 0) // Repeated branch in loop derived from `p` (through bits)
       bn_exp.c line  434 - for (i = 1; i < window; i++) { // Repeated branch + NOT necessarily constant time loop
      = bn_exp.c line  435 - if (wstart - i < 0) // Repeated branch breaks for(i=1;i < window; i++)
      = bn_exp.c line  437 - if (BN_is_bit_set(p, wstart - i)) { // Undefined Signature Repeated branch in loop on data of `p`
      = bn_exp.c line  448 - for (i = 0; i < j; i++) { //NOT constant time loop, nested repeated branch `j` depends on data `p`
       bn_exp.c line  449 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) // Undefined Signature `r` `mont` taint all
       bn_exp.c line  454 - if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx)) // Undefined Signature `r` `mont` taint all
       bn_exp.c line  461 - if (wstart < 0) // Repeated branch breaks for(;;)
       bn_exp.c line  475 - if (!BN_from_montgomery(rr, r, mont, ctx)) // Undefined Signature `r` `mont` taint all

       /* CTIME COPY TO/FROM */
       bn_exp.c line  522 - if (top > b->top)  // Branch on top is tainted due to `top` from caller Line 975
       bn_exp.c line  525 - for (i = 0, j = idx; i < top; i++, j += width) { // Repeated branch Constant time loop tainted due to `top` form caller
       bn_exp.c line  540 - if (bn_wexpand(b, top) == NULL) // Undefined signature
       bn_exp.c line  543 - if (window <= 3) { // Window tained from caller derived from `p`
       bn_exp.c line  544 - for (i = 0; i < top; i++, table += width) { // Repeated branch constant time.
       bn_exp.c line  547 - for (j = 0; j < width; j++) { // Nested loop, constant time
       bn_exp.c line  566 - for (i = 0; i < top; i++, table += width) {// Repeated branch constant time
       bn_exp.c line  569 - for (j = 0; j < xstride; j++) { //Nexted Loop constant time

       /* bn_mod_exp_mont_consttime */
       bn_exp.c line  621 - if (!BN_is_odd(m)) { // Undefined signature + Branch on `m`
       bn_exp.c line  629 - if (bits == 0) { // Branch on length of `p`
       bn_exp.c line  631 - if (BN_is_one(m)) { // Undefined signature + Branch on m
       bn_exp.c line  651 - if (!BN_MONT_CTX_set(mont, m, ctx)) // Undefined signarture `m` taints all
       bn_exp.c line  685 - window = BN_window_bits_for_ctime_exponent_size(bits); // Branch on bits derived from `p`
       bn_exp.c line  709 - ((2 * top) > // Branch on NumPowers based on `p`
       bn_exp.c line  712 - if (powerbufLen < 3072) // Branch based on length of `p`
       bn_exp.c line  717 - if ((powerbufFree = // Branch on length of `p`
       bn_exp.c line  726 - if (powerbufLen < 3072) // Branch based on length of `p`
       bn_exp.c line  740 - if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) { // Branch on data of `m`
       bn_exp.c line  743 - for (i = 1; i < top; i++) // Repeated branch constant time loop
       bn_exp.c line  748 - if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx)) // Undefined signature `mont` taints all
       bn_exp.c line  752 - if (a->neg || BN_ucmp(a, m) >= 0) { // Branch on `a` data
       bn_exp.c line  753 - if (!BN_mod(&am, a, m, ctx)) // Undefined Signature Branch on result of `a % m` am tainted
       bn_exp.c line  755 - if (!BN_to_montgomery(&am, &am, mont, ctx)) // Undefined signature `am` `mont` taints all
       bn_exp.c line  757 - } else if (!BN_to_montgomery(&am, a, mont, ctx)) // Undefined signature `am` `mont` taints all
       bn_exp.c line 1023 - if (window > 1) { // Branch based on `p`
       bn_exp.c line 1024 - if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx)) // Undefined signature `am` taints all
       bn_exp.c line 1029 - for (i = 3; i < numPowers; i++) { // Repeated branch/loop on `numPowers` derived from `p`
       bn_exp.c line 1031 - if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx)) // repeated branch/ undefined signature 
       bn_exp.c line 1040 - for (wvalue = 0, i = bits % window; i >= 0; i--, bits--) //Repeated branch/loop constant time
       bn_exp.c line 1050 - while (bits >= 0) {//  Repeated branch/ loop 
       bn_exp.c line 1054 - for (i = 0; i < window; i++, bits--) { //Rpeated branch/ nested loop constant time
       bn_exp.c line 1055 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx)) // Undefined signature / repeated branch in for loop
       bn_exp.c line 1068 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx)) // Undefined signature / repeated branch in whileloop
       bn_exp.c line 1083 - if (!BN_from_montgomery(rr, &tmp, mont, ctx)) // Undefined signature `tmp` `mont` taint all
       bn_exp.c line 1089 - if (powerbuf != NULL) { // Branch on tainted ptr

       /* BN_mod_exp_mont_word */
       bn_exp.c line 1123 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 // Undefined signature `p` taints retval
       bn_exp.c line 1124 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) { // Undefined signature `m` taints retval
       bn_exp.c line 1133 - if (!BN_is_odd(m)) { // undefined signature `m` 
       bn_exp.c line 1137 - if (m->top == 1) // Branch on `m` data
       bn_exp.c line 1141 - if (bits == 0) { // Branch on length of `p`
       bn_exp.c line 1143 - if (BN_is_one(m)) { // Undefined signature `m` taints retval
       bn_exp.c line 1151 - if (a == 0) { // Branch on `a`
       bn_exp.c line 1169 - if (!BN_MONT_CTX_set(mont, m, ctx)) // Undefined signature `m` taints all
       bn_exp.c line 1179 - for (b = bits - 2; b >= 0; b--) { // Repeated branch / constant time loop
       bn_exp.c line 1182 - if ((next_w / w) != w) { /* overflow */ //Repeated branch in loop
       bn_exp.c line 1184 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) // Undefined signature `mont` taints all
       bn_exp.c line 1188 - if (!BN_MOD_MUL_WORD(r, w, m)) // Undefined  signature all taint
       bn_exp.c line 1200 - if (BN_is_bit_set(p, b)) { // Repeated branch in loop, undefined signature
       bn_exp.c line 1202 - if ((next_w / a) != w) { /* overflow */ // Repeated Branch in loop on `a`
       bn_exp.c line 1204 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) // Repeated branch in loop, undefined signature
       bn_exp.c line 1208 - if (!BN_MOD_MUL_WORD(r, w, m)) // Repeated branch in loop, undefined signature
       bn_exp.c line 1218 - if (w != 1) { // Branch on w
       bn_exp.c line 1220 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) // Undefined signature
       bn_exp.c line 1224 - if (!BN_MOD_MUL_WORD(r, w, m))  // Undefined signature

       /* bn_mod_exp_simple - unused */
       bn_exp.c line 1256 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 // Undefined signature `a` taints retval
       bn_exp.c line 1257 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) { // Undefined signature `m` taints retval
       bn_exp.c line 1264 - if (bits == 0) {
       bn_exp.c line 1281 - if (!BN_nnmod(val[0], a, m, ctx))
       bn_exp.c line 1289 - window = BN_window_bits_for_exponent_size(bits);
       bn_exp.c line 1290 - if (window > 1) {
       bn_exp.c line 1294 - for (i = 1; i < j; i++) {
       bn_exp.c line 1312 - if (BN_is_bit_set(p, wstart) == 0) {
       bn_exp.c line 1316 - if (wstart == 0)
       bn_exp.c line 1329 - for (i = 1; i < window; i++) {
       bn_exp.c line 1330 - if (wstart - i < 0)
       bn_exp.c line 1332 - if (BN_is_bit_set(p, wstart - i)) {
       bn_exp.c line 1343 - for (i = 0; i < j; i++) {
       bn_exp.c line 1356 - if (wstart < 0)
    #+END_SRC
    
**** Classification - BN_mod_exp_simple
    | Err. Type        | Qty | Comments |
    | False Positive   |     |          |
    | Validation       |     |          |
    | Looped Branch    |     |          |
    | Un-looped Branch |     |          |
    | Low entropy      |     |          |
    | High entropy     |     |          |
    | Total Reported   |     |          |

**** Classification - BN_mod_exp_recp
    | Err. Type        | Qty | Comments |
    | False Positive   |     |          |
    | Validation       |     |          |
    | Looped Branch    |     |          |
    | Un-looped Branch |     |          |
    | Low entropy      |     |          |
    | High entropy     |     |          |
    | Total Reported   |     |          |

**** Classification - BN_mod_exp_mont
    | Err. Type        | Qty | Comments |
    | False Positive   |     |          |
    | Validation       |     |          |
    | Looped Branch    |     |          |
    | Un-looped Branch |     |          |
    | Low entropy      |     |          |
    | High entropy     |     |          |
    | Total Reported   |     |          |

**** Classification - BN_mod_exp_mont_consttime
    | Err. Type        | Qty | Comments |
    | False Positive   |     |          |
    | Validation       |     |          |
    | Looped Branch    |     |          |
    | Un-looped Branch |     |          |
    | Low entropy      |     |          |
    | High entropy     |     |          |
    | Total Reported   |     |          |

*** Commit *062b602c89*
    Tainted/Untrusted: p, m
    Whitelist: bits
    
    99 Results
    #+BEGIN_SRC c
      bn_exp.c line   47 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0) {
      bn_exp.c line   54 - if ((r == a) || (r == p))
      bn_exp.c line   66 - if (BN_is_odd(p)) {
      bn_exp.c line   77 - if (BN_is_bit_set(p, i)) {
      bn_exp.c line  144 - if (BN_is_odd(m)) {
      bn_exp.c line  146 - if (a->top == 1 && !a->neg
      bn_exp.c line  147 - && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)
      bn_exp.c line  148 - && (BN_get_flags(a, BN_FLG_CONSTTIME) == 0)
      bn_exp.c line  149 - && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0)) {

      /* BN_mod_exp_recp */
VH    bn_exp.c line  181 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
VH    bn_exp.c line  182 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
VH    bn_exp.c line  183 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
UH    bn_exp.c line  192 - if (BN_is_one(m)) {
UH    bn_exp.c line  208 - if (m->neg) {
VH    bn_exp.c line  210 - if (!BN_copy(aa, m))
VH    bn_exp.c line  213 - if (BN_RECP_CTX_set(&recp, aa, ctx) <= 0)
VH    bn_exp.c line  216 - if (BN_RECP_CTX_set(&recp, m, ctx) <= 0)
VH    bn_exp.c line  220 - if (!BN_nnmod(val[0], a, m, ctx))
VH    bn_exp.c line  230 - if (!BN_mod_mul_reciprocal(aa, val[0], val[0], &recp, ctx))
VRH   bn_exp.c line  234 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
RL   bn_exp.c line  251 - if (BN_is_bit_set(p, wstart) == 0) {
RL    bn_exp.c line  271 - if (BN_is_bit_set(p, wstart - i)) {

      /* BN_mod_exp_mont */
VH    bn_exp.c line  317 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
VH    bn_exp.c line  318 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
VH    bn_exp.c line  319 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
VH    bn_exp.c line  327 - if (!BN_is_odd(m)) {
UH    bn_exp.c line  334 - if (BN_is_one(m)) {
VH    bn_exp.c line  359 - if (!BN_MONT_CTX_set(mont, m, ctx))
UL    bn_exp.c line  363 - if (a->neg || BN_ucmp(a, m) >= 0) {
VH    bn_exp.c line  364 - if (!BN_nnmod(val[0], a, m, ctx))
UH    bn_exp.c line  369 - if (BN_is_zero(aa)) {
VH    bn_exp.c line  374 - if (!BN_to_montgomery(val[0], aa, mont, ctx))
VH    bn_exp.c line  379 - if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))
RH    bn_exp.c line  382 - for (i = 1; i < j; i++) {
VRH   bn_exp.c line  383 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
UH    bn_exp.c line  398 - if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
VH    bn_exp.c line  399 - if (bn_wexpand(r, j) == NULL)
RH    bn_exp.c line  403 - for (i = 1; i < j; i++)
VH    bn_exp.c line  413 - if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))
RL    bn_exp.c line  416 - if (BN_is_bit_set(p, wstart) == 0) {
VRH   bn_exp.c line  418 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
RL    bn_exp.c line  437 - if (BN_is_bit_set(p, wstart - i)) {
RL    bn_exp.c line  448 - for (i = 0; i < j; i++) {
VRH   bn_exp.c line  449 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
VRH   bn_exp.c line  454 - if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))
VH    bn_exp.c line  475 - if (!BN_from_montgomery(rr, r, mont, ctx))

      bn_exp.c line  522 - if (top > b->top)
      bn_exp.c line  525 - for (i = 0, j = idx; i < top; i++, j += width) {
      bn_exp.c line  540 - if (bn_wexpand(b, top) == NULL)
      bn_exp.c line  544 - for (i = 0; i < top; i++, table += width) {
      bn_exp.c line  566 - for (i = 0; i < top; i++, table += width) {

      /* BN_mod_exp_mont_consttime */
VH    bn_exp.c line  621 - if (!BN_is_odd(m)) {
UH    bn_exp.c line  631 - if (BN_is_one(m)) {
VH    bn_exp.c line  651 - if (!BN_MONT_CTX_set(mont, m, ctx))
UH    bn_exp.c line  709 - ((2 * top) > 
UH    bn_exp.c line  712 - if (powerbufLen < 3072)
UH    bn_exp.c line  717 - if ((powerbufFree =
UH    bn_exp.c line  726 - if (powerbufLen < 3072)
UH    bn_exp.c line  740 - if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
RH    bn_exp.c line  743 - for (i = 1; i < top; i++)
VH    bn_exp.c line  748 - if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
UH *  bn_exp.c line  752 - if (a->neg || BN_ucmp(a, m) >= 0) {
VH    bn_exp.c line  753 - if (!BN_mod(&am, a, m, ctx))
VH    bn_exp.c line  755 - if (!BN_to_montgomery(&am, &am, mont, ctx))
VH    bn_exp.c line  757 - } else if (!BN_to_montgomery(&am, a, mont, ctx))
VH    bn_exp.c line 1024 - if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
VRH   bn_exp.c line 1031 - if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
VRH   bn_exp.c line 1055 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))
VRH   bn_exp.c line 1068 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))
VH    bn_exp.c line 1083 - if (!BN_from_montgomery(rr, &tmp, mont, ctx))
VH    bn_exp.c line 1089 - if (powerbuf != NULL) {

      /* BN_mod_exp_mont_word */
VH    bn_exp.c line 1123 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
VH    bn_exp.c line 1124 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
UH    bn_exp.c line 1133 - if (!BN_is_odd(m)) {
UH    bn_exp.c line 1137 - if (m->top == 1)
UH    bn_exp.c line 1143 - if (BN_is_one(m)) {
VH    bn_exp.c line 1151 - if (a == 0) {
VH    bn_exp.c line 1169 - if (!BN_MONT_CTX_set(mont, m, ctx))
RH    bn_exp.c line 1182 - if ((next_w / w) != w) { /* overflow */
VRH   bn_exp.c line 1184 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
VRH   bn_exp.c line 1188 - if (!BN_MOD_MUL_WORD(r, w, m))
RL    bn_exp.c line 1200 - if (BN_is_bit_set(p, b)) {
VRH   bn_exp.c line 1202 - if ((next_w / a) != w) { /* overflow */
VRH   bn_exp.c line 1204 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
VRH   bn_exp.c line 1208 - if (!BN_MOD_MUL_WORD(r, w, m))
UH    bn_exp.c line 1218 - if (w != 1) {
VH    bn_exp.c line 1220 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
VH    bn_exp.c line 1224 - if (!BN_MOD_MUL_WORD(r, w, m))

      /* bn_mod_exp_simple */
VH    bn_exp.c line 1255 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
VH    bn_exp.c line 1256 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
UH    bn_exp.c line 1266 - if (BN_is_one(m)) {
VH    bn_exp.c line 1281 - if (!BN_nnmod(val[0], a, m, ctx))
VH    bn_exp.c line 1291 - if (!BN_mod_mul(d, val[0], val[0], m, ctx))
VRH   bn_exp.c line 1295 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
RL    bn_exp.c line 1312 - if (BN_is_bit_set(p, wstart) == 0) {
VRH   bn_exp.c line 1314 - if (!BN_mod_mul(r, r, r, m, ctx))
RL    bn_exp.c line 1332 - if (BN_is_bit_set(p, wstart - i)) {
VRH   bn_exp.c line 1344 - if (!BN_mod_mul(r, r, r, m, ctx))
VRH   bn_exp.c line 1349 - if (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx))
    #+END_SRC

**** Classification - BN_mod_exp_simple
    | Err. Type        | Qty | Comments |
    | False Positive   |   0 |          |
    | Validation       |   8 |          |
    | Looped Branch    |   6 |          |
    | Un-looped Branch |   6 |          |
    | High entropy     |   9 |          |
    | Low entropy      |   2 |          |
    | Total Reported   |  11 |          |
    
**** Classification - BN_mod_exp_mont_word
    | Err. Type        | Qty | Comments           |
    | False Positive   |   0 | if (a == 0) maybe? |
    | Validation       |  11 |                    |
    | Looped Branch    |   7 |                    |
    | Un-looped Branch |  10 |                    |
    | High entropy     |  16 |                    |
    | Low entropy      |   1 |                    |
    | Total Reported   |  17 |                    |

**** Classification - BN_mod_exp_mont_consttime
    | Err. Type        | Qty | Comments |
    | False Positive   |   0 |          |
    | Validation       |  10 |          |
    | Looped Branch    |   4 |          |
    | Un-looped Branch |  16 |          |
    | High entropy     |  20 |          |
    | Low entropy      |   0 |          |
    | Total Reported   |  20 |          |

**** Classification - BN_mod_exp_mont
    | Err. Type        | Qty | Comments |
    | False Positive   |   0 |          |
    | Validation       |  15 |          |
    | Looped Branch    |   9 |          |
    | Un-looped Branch |  15 |          |
    | High entropy     |  20 |          |
    | Low entropy      |   4 |          |
    | Total Reported   |  24 |          |

**** Classification - BN_mod_exp_recp
    | Err. Type        | Qty | Comments |
    | False Positive   |   0 |          |
    | Validation       |   9 |          |
    | Looped Branch    |   3 |          |
    | Un-looped Branch |  10 |          |
    | High entropy     |  11 |          |
    | Low entropy      |   2 |          |
    | Total Reported   |  13 |          |
    
*** Commit *d47280a59f*
**** No whitelist
     Tainted/Untrusted: p, m
     
     #+BEGIN_SRC c
       bn_exp.c line   47 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0) {
       bn_exp.c line   54 - if ((r == a) || (r == p))
       bn_exp.c line   66 - if (BN_is_odd(p)) {
       bn_exp.c line   74 - for (i = 1; i < bits; i++) {
       bn_exp.c line   77 - if (BN_is_bit_set(p, i)) {
       bn_exp.c line  144 - if (BN_is_odd(m)) {
       bn_exp.c line  146 - if (a->top == 1 && !a->neg
       bn_exp.c line  147 - && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)
       bn_exp.c line  148 - && (BN_get_flags(a, BN_FLG_CONSTTIME) == 0)
       bn_exp.c line  149 - && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0)) {
  
       /* BN_mod_exp_recp */
V      bn_exp.c line  181 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line  182 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line  183 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
UL     bn_exp.c line  190 - if (bits == 0) {
UL     bn_exp.c line  192 - if (BN_is_one(m)) {
UL     bn_exp.c line  208 - if (m->neg) {
V      bn_exp.c line  210 - if (!BN_copy(aa, m))
V      bn_exp.c line  213 - if (BN_RECP_CTX_set(&recp, aa, ctx) <= 0)
V      bn_exp.c line  216 - if (BN_RECP_CTX_set(&recp, m, ctx) <= 0)
V      bn_exp.c line  220 - if (!BN_nnmod(val[0], a, m, ctx))
UL     bn_exp.c line  228 - window = BN_window_bits_for_exponent_size(bits);
UL     bn_exp.c line  229 - if (window > 1) {
V      bn_exp.c line  230 - if (!BN_mod_mul_reciprocal(aa, val[0], val[0], &recp, ctx))
RL     bn_exp.c line  233 - for (i = 1; i < j; i++) {
V      bn_exp.c line  234 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
RH     bn_exp.c line  251 - if (BN_is_bit_set(p, wstart) == 0) {
RL     bn_exp.c line  255 - if (wstart == 0)
RL     bn_exp.c line  268 - for (i = 1; i < window; i++) {
RL     bn_exp.c line  269 - if (wstart - i < 0)
RH     bn_exp.c line  271 - if (BN_is_bit_set(p, wstart - i)) {
RL     bn_exp.c line  282 - for (i = 0; i < j; i++) {
RL     bn_exp.c line  295 - if (wstart < 0)

       /* BN_mod_exp_mont */ 
V      bn_exp.c line  317 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line  318 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line  319 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
V      bn_exp.c line  327 - if (!BN_is_odd(m)) {
UL     bn_exp.c line  332 - if (bits == 0) {
UL     bn_exp.c line  334 - if (BN_is_one(m)) {
V      bn_exp.c line  359 - if (!BN_MONT_CTX_set(mont, m, ctx))
C      bn_exp.c line  363 - if (a->neg || BN_ucmp(a, m) >= 0) {
V      bn_exp.c line  364 - if (!BN_nnmod(val[0], a, m, ctx))
UL     bn_exp.c line  369 - if (BN_is_zero(aa)) {
V      bn_exp.c line  374 - if (!BN_to_montgomery(val[0], aa, mont, ctx))
UL     bn_exp.c line  377 - window = BN_window_bits_for_exponent_size(bits);
UL     bn_exp.c line  378 - if (window > 1) {
V      bn_exp.c line  379 - if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))
RL     bn_exp.c line  382 - for (i = 1; i < j; i++) {
V      bn_exp.c line  383 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
UL     bn_exp.c line  398 - if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
V      bn_exp.c line  399 - if (bn_wexpand(r, j) == NULL)
UL     bn_exp.c line  403 - for (i = 1; i < j; i++)
V      bn_exp.c line  413 - if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))
RH     bn_exp.c line  416 - if (BN_is_bit_set(p, wstart) == 0) {
V      bn_exp.c line  418 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
RL     bn_exp.c line  421 - if (wstart == 0)
RL     bn_exp.c line  434 - for (i = 1; i < window; i++) {
RL     bn_exp.c line  435 - if (wstart - i < 0)
RH     bn_exp.c line  437 - if (BN_is_bit_set(p, wstart - i)) {
RL     bn_exp.c line  448 - for (i = 0; i < j; i++) {
V      bn_exp.c line  449 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
V      bn_exp.c line  454 - if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))
RL     bn_exp.c line  461 - if (wstart < 0)
V      bn_exp.c line  475 - if (!BN_from_montgomery(rr, r, mont, ctx))

       bn_exp.c line  522 - if (top > b->top)
       bn_exp.c line  525 - for (i = 0, j = idx; i < top; i++, j += width) {
       bn_exp.c line  540 - if (bn_wexpand(b, top) == NULL)
       bn_exp.c line  543 - if (window <= 3) {
       bn_exp.c line  544 - for (i = 0; i < top; i++, table += width) {
       bn_exp.c line  547 - for (j = 0; j < width; j++) {
       bn_exp.c line  566 - for (i = 0; i < top; i++, table += width) {
       bn_exp.c line  569 - for (j = 0; j < xstride; j++) {

       /* BN_mod_exp_mont_consttime */ 
V      bn_exp.c line  621 - if (!BN_is_odd(m)) {
UL     bn_exp.c line  629 - if (bits == 0) {
UL     bn_exp.c line  631 - if (BN_is_one(m)) {
V      bn_exp.c line  651 - if (!BN_MONT_CTX_set(mont, m, ctx))
UL     bn_exp.c line  685 - window = BN_window_bits_for_ctime_exponent_size(bits);
UL     bn_exp.c line  709 - ((2 * top) >
UL     bn_exp.c line  712 - if (powerbufLen < 3072)
V      bn_exp.c line  717 - if ((powerbufFree =
UL     bn_exp.c line  726 - if (powerbufLen < 3072)
UL     bn_exp.c line  740 - if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
RL     bn_exp.c line  743 - for (i = 1; i < top; i++)
V      bn_exp.c line  748 - if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
C      bn_exp.c line  752 - if (a->neg || BN_ucmp(a, m) >= 0) {
V      bn_exp.c line  753 - if (!BN_mod(&am, a, m, ctx))
V      bn_exp.c line  755 - if (!BN_to_montgomery(&am, &am, mont, ctx))
V      bn_exp.c line  757 - } else if (!BN_to_montgomery(&am, a, mont, ctx))
UL     bn_exp.c line 1023 - if (window > 1) {
V      bn_exp.c line 1024 - if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
RL     bn_exp.c line 1029 - for (i = 3; i < numPowers; i++) {
V      bn_exp.c line 1031 - if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
RL     bn_exp.c line 1040 - for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
RL     bn_exp.c line 1050 - while (bits >= 0) {
RL     bn_exp.c line 1054 - for (i = 0; i < window; i++, bits--) {
V      bn_exp.c line 1055 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))
V      bn_exp.c line 1068 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))
V      bn_exp.c line 1083 - if (!BN_from_montgomery(rr, &tmp, mont, ctx))
V      bn_exp.c line 1089 - if (powerbuf != NULL) {

       /* BN_mod_exp_mont_word */
V      bn_exp.c line 1123 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line 1124 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
V      bn_exp.c line 1133 - if (!BN_is_odd(m)) {
UL     bn_exp.c line 1137 - if (m->top == 1)
UL     bn_exp.c line 1141 - if (bits == 0) {
UL     bn_exp.c line 1143 - if (BN_is_one(m)) {
UL     bn_exp.c line 1151 - if (a == 0) {
V      bn_exp.c line 1169 - if (!BN_MONT_CTX_set(mont, m, ctx))
RL     bn_exp.c line 1179 - for (b = bits - 2; b >= 0; b--) {
RL     bn_exp.c line 1182 - if ((next_w / w) != w) { /* overflow */
V      bn_exp.c line 1184 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
V      bn_exp.c line 1188 - if (!BN_MOD_MUL_WORD(r, w, m))
RH     bn_exp.c line 1200 - if (BN_is_bit_set(p, b)) {
RL     bn_exp.c line 1202 - if ((next_w / a) != w) { /* overflow */
V      bn_exp.c line 1204 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
V      bn_exp.c line 1208 - if (!BN_MOD_MUL_WORD(r, w, m))
UL     bn_exp.c line 1218 - if (w != 1) {
V      bn_exp.c line 1220 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
V      bn_exp.c line 1224 - if (!BN_MOD_MUL_WORD(r, w, m))

       /* BN_mod_exp_simple */
RH     bn_exp.c line 1312 - if (BN_is_bit_set(p, wstart) == 0) {
RH     bn_exp.c line 1332 - if (BN_is_bit_set(p, wstart - i)) {
RL*    bn_exp.c line 1343 - for (i = 0; i < j; i++) {
RL     bn_exp.c line 1294 - for (i = 1; i < j; i++) {
RL     bn_exp.c line 1316 - if (wstart == 0)
RL     bn_exp.c line 1329 - for (i = 1; i < window; i++) {
RL     bn_exp.c line 1330 - if (wstart - i < 0)
RL     bn_exp.c line 1356 - if (wstart < 0)
UL     bn_exp.c line 1266 - if (BN_is_one(m)) {
UL     bn_exp.c line 1264 - if (bits == 0) {
UL     bn_exp.c line 1289 - window = BN_window_bits_for_exponent_size(bits);
UL     bn_exp.c line 1290 - if (window > 1) {
V      bn_exp.c line 1255 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line 1256 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
V      bn_exp.c line 1281 - if (!BN_nnmod(val[0], a, m, ctx))
V      bn_exp.c line 1291 - if (!BN_mod_mul(d, val[0], val[0], m, ctx))
V       bn_exp.c line 1295 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
V      bn_exp.c line 1314 - if (!BN_mod_mul(r, r, r, m, ctx))
V      bn_exp.c line 1344 - if (!BN_mod_mul(r, r, r, m, ctx))
V      bn_exp.c line 1349 - if (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx))
     #+END_SRC 
     
**** With Whitelist
     Tainted/Untrusted: p,m
     Whitelist: bits
     
     #+BEGIN_SRC c
      bn_exp.c line   47 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0) {
      bn_exp.c line   54 - if ((r == a) || (r == p))
      bn_exp.c line   66 - if (BN_is_odd(p)) {
      bn_exp.c line   77 - if (BN_is_bit_set(p, i)) {
      bn_exp.c line  144 - if (BN_is_odd(m)) {
      bn_exp.c line  146 - if (a->top == 1 && !a->neg
      bn_exp.c line  147 - && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)
      bn_exp.c line  148 - && (BN_get_flags(a, BN_FLG_CONSTTIME) == 0)
      bn_exp.c line  149 - && (BN_get_flags(m, BN_FLG_CONSTTIME) == 0)) {
       /* BN_mod_exp_recp */
RH    bn_exp.c line  251 - if (BN_is_bit_set(p, wstart) == 0) {
RH    bn_exp.c line  271 - if (BN_is_bit_set(p, wstart - i)) {
UL    bn_exp.c line  192 - if (BN_is_one(m)) {
UL    bn_exp.c line  208 - if (m->neg) {
V     bn_exp.c line  181 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V     bn_exp.c line  182 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
V     bn_exp.c line  183 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
V     bn_exp.c line  210 - if (!BN_copy(aa, m))
V     bn_exp.c line  213 - if (BN_RECP_CTX_set(&recp, aa, ctx) <= 0)
V     bn_exp.c line  216 - if (BN_RECP_CTX_set(&recp, m, ctx) <= 0)
V     bn_exp.c line  220 - if (!BN_nnmod(val[0], a, m, ctx))
V     bn_exp.c line  230 - if (!BN_mod_mul_reciprocal(aa, val[0], val[0], &recp, ctx))
V     bn_exp.c line  234 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||

       /* BN_mod_exp_mont */ 
V     bn_exp.c line  317 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V     bn_exp.c line  318 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
V     bn_exp.c line  319 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
V     bn_exp.c line  327 - if (!BN_is_odd(m)) {
UL    bn_exp.c line  334 - if (BN_is_one(m)) {
V     bn_exp.c line  359 - if (!BN_MONT_CTX_set(mont, m, ctx))
C     bn_exp.c line  363 - if (a->neg || BN_ucmp(a, m) >= 0) {
V     bn_exp.c line  364 - if (!BN_nnmod(val[0], a, m, ctx))
UL    bn_exp.c line  369 - if (BN_is_zero(aa)) {
V     bn_exp.c line  374 - if (!BN_to_montgomery(val[0], aa, mont, ctx))
V     bn_exp.c line  379 - if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))
RL    bn_exp.c line  382 - for (i = 1; i < j; i++) {
V     bn_exp.c line  383 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
UL    bn_exp.c line  398 - if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
V     bn_exp.c line  399 - if (bn_wexpand(r, j) == NULL)
RL    bn_exp.c line  403 - for (i = 1; i < j; i++)
V     bn_exp.c line  413 - if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))
RH    bn_exp.c line  416 - if (BN_is_bit_set(p, wstart) == 0) {
V     bn_exp.c line  418 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
RH    bn_exp.c line  437 - if (BN_is_bit_set(p, wstart - i)) {
RL    bn_exp.c line  448 - for (i = 0; i < j; i++) {
V     bn_exp.c line  449 - if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
V     bn_exp.c line  454 - if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))
V     bn_exp.c line  475 - if (!BN_from_montgomery(rr, r, mont, ctx))

      bn_exp.c line  522 - if (top > b->top)
      bn_exp.c line  525 - for (i = 0, j = idx; i < top; i++, j += width) {
      bn_exp.c line  540 - if (bn_wexpand(b, top) == NULL)
      bn_exp.c line  544 - for (i = 0; i < top; i++, table += width) {
      bn_exp.c line  566 - for (i = 0; i < top; i++, table += width) {

       /* BN_mod_exp_mont_consttime */ 
V     bn_exp.c line  621 - if (!BN_is_odd(m)) {
UL    bn_exp.c line  631 - if (BN_is_one(m)) {
V     bn_exp.c line  651 - if (!BN_MONT_CTX_set(mont, m, ctx))
UL    bn_exp.c line  709 - ((2 * top) >
UL    bn_exp.c line  712 - if (powerbufLen < 3072)
V     bn_exp.c line  717 - if ((powerbufFree =
UL    bn_exp.c line  726 - if (powerbufLen < 3072)
UL    bn_exp.c line  740 - if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
UL    bn_exp.c line  743 - for (i = 1; i < top; i++)
V     bn_exp.c line  748 - if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
C     bn_exp.c line  752 - if (a->neg || BN_ucmp(a, m) >= 0) {
V     bn_exp.c line  753 - if (!BN_mod(&am, a, m, ctx))
V     bn_exp.c line  755 - if (!BN_to_montgomery(&am, &am, mont, ctx))
V     bn_exp.c line  757 - } else if (!BN_to_montgomery(&am, a, mont, ctx))
V     bn_exp.c line 1024 - if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
V     bn_exp.c line 1031 - if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
V     bn_exp.c line 1055 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))
V     bn_exp.c line 1068 - if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))
V     bn_exp.c line 1083 - if (!BN_from_montgomery(rr, &tmp, mont, ctx))
V     bn_exp.c line 1089 - if (powerbuf != NULL) {

       /* BN_mod_exp_mont_word */
V     bn_exp.c line 1123 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V     bn_exp.c line 1124 - || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
V     bn_exp.c line 1133 - if (!BN_is_odd(m)) {
UL    bn_exp.c line 1137 - if (m->top == 1)
UL    bn_exp.c line 1143 - if (BN_is_one(m)) {
UL    bn_exp.c line 1151 - if (a == 0) {
V     bn_exp.c line 1169 - if (!BN_MONT_CTX_set(mont, m, ctx))
RL    bn_exp.c line 1182 - if ((next_w / w) != w) { /* overflow */
V     bn_exp.c line 1184 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
V     bn_exp.c line 1188 - if (!BN_MOD_MUL_WORD(r, w, m))
RH    bn_exp.c line 1200 - if (BN_is_bit_set(p, b)) {
RL    bn_exp.c line 1202 - if ((next_w / a) != w) { /* overflow */
V     bn_exp.c line 1204 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
V     bn_exp.c line 1208 - if (!BN_MOD_MUL_WORD(r, w, m))
UL    bn_exp.c line 1218 - if (w != 1) {
V     bn_exp.c line 1220 - if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
V     bn_exp.c line 1224 - if (!BN_MOD_MUL_WORD(r, w, m))

       /* BN_mod_exp_simple */
V     bn_exp.c line 1255 - if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
V     bn_exp.c line 1256 - || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
UL    bn_exp.c line 1266 - if (BN_is_one(m)) {
V     bn_exp.c line 1281 - if (!BN_nnmod(val[0], a, m, ctx))
V     bn_exp.c line 1291 - if (!BN_mod_mul(d, val[0], val[0], m, ctx))
V     bn_exp.c line 1295 - if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
RH    bn_exp.c line 1312 - if (BN_is_bit_set(p, wstart) == 0) {
V     bn_exp.c line 1314 - if (!BN_mod_mul(r, r, r, m, ctx))
RH    bn_exp.c line 1332 - if (BN_is_bit_set(p, wstart - i)) {
V     bn_exp.c line 1344 - if (!BN_mod_mul(r, r, r, m, ctx))
V     bn_exp.c line 1349 - if (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx))
     #+END_SRC
* LibGcrypt 1.5.2
** mpi-powm.c test
   Tainted: mod, expo :: Untrusted: base
   There is supposed to be a square and multiply vulnerability in this version
*** Results
    : gcry_mpi_powm function :
    mpi-pow.c line 105 - if (bsize > msize)
    mpi-pow.c line 113 - MPN_COPY ( bp, base->d, bsize )
    mpi-pow.c line 120 - MPN_NORMALIZE( bp, bsize )
    mpi-pow.c line 125 - if (!bsize)
    mpi-pow.c line 134 - if ( rp == bp )
    mpi-pow.c line 137 - gcry_assert (!bp_marker)
    mpi-pow.c line 140 - MPN_COPY(bp, rp, bsize)
    mpi-pow.c line 164 - MPN_COPY ( rp, bp, bsize )
    mpi-pow.c line 181 - negative_result = (ep[0] & 1) && base->sign;
    mpi-pow.c line 185 - count_leading_zeros (c, e);
    mpi-pow.c line 199 - while (c)
    mpi-pow.c line 205 - if ( rsize < KARATSUBA_THRESHOLD )
    mpi-pow.c line 209 - if ( !tspace )
    mpi-pow.c line 214 - else if ( tsize < (2*rsize) )
    mpi-pow.c line 224 - if ( xsize > msize )
    mpi-pow.c line 233 - if ( (mpi_limb_signed_t)e < 0 ) -- Square and Multipy if bit is negative only
    mpi-pow.c line 236 - if( bsize < KARATSUBA_THRESHOLD )
    mpi-pow.c line 243 - if ( xsize > msize )
    mpi-pow.c line 273 - if ( carry_limb )
    mpi-pow.c line 281 - MPN_COPY (res->d, rp, rsize)
    mpi-pow.c line 285 - if ( rsize >= msize )
    mpi-pow.c line 294 - MPN_NORMALIZE (rp, rsize)
    mpi-pow.c line 300 - if ( negative_result && rsize )
    mpi-pow.c line 307 - MPN_NORMALIZE(rp, rsize)
    mpi-pow.c line 316 - if (bp_marker)
    mpi-pow.c line 322 - if (tspace)

* LibGcrypt 1.7.6
** mpi-powm.c test
   This function is used to do modular exponentiation and uses CRT.
*** Commit *319237301b* - O0 Tainted/Untrusted: base, mod, expo
    mpi-pow.c line  371 - if( ssize < KARATSUBA_THRESHOLD )
    mpi-pow.c line  376 - if (rsize + ssize > msize)
    mpi-pow.c line  434 - MPN_NORMALIZE(ep, esize);
    mpi-pow.c line  447 - esec = mpi_is_secure(expo);
    mpi-pow.c line  448 - msec = mpi_is_secure(mod);
    mpi-pow.c line  449 - bsec = mpi_is_secure(base);
    mpi-pow.c line  453 - if (!msize)
    mpi-pow.c line  460 - res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;
    mpi-pow.c line  461 - if (res->nlimbs)
    mpi-pow.c line  478 - if (mod_shift_cnt)
    mpi-pow.c line  481 - MPN_COPY( mp, mod->d, msize );
    mpi-pow.c line  485 - if (bsize > msize)
    mpi-pow.c line  500 - MPN_NORMALIZE( bp, bsize );
    mpi-pow.c line  515 - if ( rp == 0 )
    mpi-pow.c line  523 - if ( rp == ep )
    mpi-pow.c line  532 - if (res->alloced < size)
    mpi-pow.c line  553 - negative_result = (ep[0] & 1) && bsign;
    mpi-pow.c line  563 - if (xsize >= base_u_size)
    mpi-pow.c line  571 - if (max_u_size < base_u_size)
    mpi-pow.c line  577 - MPN_ZERO (base_u, max_u_size);
    mpi-pow.c line  609 - if (e == 0)
    mpi-pow.c line  632 - if (c >= W)
    mpi-pow.c line  657 - for (j += W - c0; j; j--)  ==Paper Result==
    mpi-pow.c line  691 - if (c != 0)
    mpi-pow.c line  699 - while (j--)
    mpi-pow.c line  706 - if (e != 0)
    mpi-pow.c line  732 - for (; c; c--)
    mpi-pow.c line  746 - if ( mod_shift_cnt )
    mpi-pow.c line  750 - if ( carry_limb )
    mpi-pow.c line  756 - else if (res->d != rp)
    mpi-pow.c line  762 - if ( rsize >= msize )
    mpi-pow.c line  769 - if ( mod_shift_cnt )
    mpi-pow.c line  771 - MPN_NORMALIZE (rp, rsize);
    mpi-pow.c line  782 - if ( mod_shift_cnt )
    mpi-pow.c line  787 - MPN_NORMALIZE(rp, rsize);
    mpi-pow.c line  789 - gcry_assert (res->d == rp);
    mpi-pow.c line  794 - if (mp_marker)
    mpi-pow.c line  800 - if (xp_marker)
*** Results - O0 Tainted: mod, expo :: Untrusted: base
    mpi-pow.c line 371 - mul_mod: if( ssize < KARATSUBA_THRESHOLD )
    mpi-pow.c line 376 - mul_mod: if (rsize + ssize > msize)
    mpi-pow.c line 434 - _gcry_mpi_powm: MPN_NORMALIZE(ep, esize)
    mpi-pow.c line 461 - _gcry_mpi_powm: if (res->nlimbs)
    mpi-pow.c line 485 - _gcry_mpi_powm: if (bsize > msize)
    mpi-pow.c line 493 - _gcry_mpi_powm: MPN_COPY ( bp, base->d, bsize )
    mpi-pow.c line 500 - _gcry_mpi_powm: MPN_NORMALIZE( bp, bsize )
    mpi-pow.c line 505 - _gcry_mpi_powm: if (!bsize)
    mpi-pow.c line 518 - _gcry_mpi_powm: gcry_assert (!bp_marker)
    mpi-pow.c line 553 - _gcry_mpi_powm: negative_result = (ep[0] & 1) && bsign;
    mpi-pow.c line 560 - _gcry_mpi_powm: MPN_COPY (precomp[0], bp, bsize)
    mpi-pow.c line 563 - _gcry_mpi_powm: if (xsize >= base_u_size)
    mpi-pow.c line 571 - _gcry_mpi_powm: if (max_u_size < base_u_size)
    mpi-pow.c line 573 - _gcry_mpi_powm: MPN_COPY (precomp[i], rp, rsize)
    mpi-pow.c line 577 - _gcry_mpi_powm: MPN_ZERO (base_u, max_u_size)
    mpi-pow.c line 597 - _gcry_mpi_powm: MPN_ZERO (rp, rsize)
    mpi-pow.c line 599 - _gcry_mpi_powm: MPN_COPY ( rp, bp, bsize )
    mpi-pow.c line 609 - _gcry_mpi_powm: if (e == 0)
    mpi-pow.c line 632 - _gcry_mpi_powm: if (c >= W)
    mpi-pow.c line 657 - _gcry_mpi_powm: for (j += W - c0; j; j--)
    mpi-pow.c line 691 - _gcry_mpi_powm: if (c != 0)
    mpi-pow.c line 699 - _gcry_mpi_powm: while (j--)
    mpi-pow.c line 706 - _gcry_mpi_powm: if (e != 0)
    mpi-pow.c line 732 - _gcry_mpi_powm: for (; c; c--)
    mpi-pow.c line 750 - _gcry_mpi_powm: if ( carry_limb )
    mpi-pow.c line 758 - _gcry_mpi_powm: MPN_COPY (res->d, rp, rsize)
    mpi-pow.c line 762 - _gcry_mpi_powm: if ( rsize >= msize )
    mpi-pow.c line 771 - _gcry_mpi_powm: MPN_NORMALIZE (rp, rsize)
    mpi-pow.c line 780 - _gcry_mpi_powm: if ( negative_result && rsize )
    mpi-pow.c line 787 - _gcry_mpi_powm: MPN_NORMALIZE(rp, rsize)
    mpi-pow.c line 796 - _gcry_mpi_powm: if (bp_marker)
*** Results - O2 Tainted: mod, expo :: Untrusted: base
    ./mpi-inline.h line 97  - _gcry_mpih_sub_1: if( s2_limb > x )
    ./mpi-inline.h line 98  - _gcry_mpih_sub_1: while( --s1_size )
    ./mpi-inline.h line 101 - _gcry_mpih_sub_1: if( x )
    ./mpi-inline.h line 108 - _gcry_mpih_sub_1: if( res_ptr != s1_ptr )
    ./mpi-inline.h line 110 - _gcry_mpih_sub_1: for( i=0; i < s1_size-1; i++ )
    ./mpi-inline.h line 127 - _gcry_mpih_sub: if( s1_size - s2_size )
    ./mpi-inline.h line 128 -
    mpi-pow.c line 371 - mul_mod: if( ssize < KARATSUBA_THRESHOLD ) -
    mpi-pow.c line 376 - mul_mod: if (rsize + ssize > msize)
    mpi-pow.c line 485 - _gcry_mpi_powm: if (bsize > msize)
    mpi-pow.c line 500 - _gcry_mpi_powm: MPN_NORMALIZE( bp, bsize )
    mpi-pow.c line 505 - _gcry_mpi_powm: if (!bsize)
    mpi-pow.c line 560 - _gcry_mpi_powm: MPN_COPY (precomp[0], bp, bsize)
    mpi-pow.c line 563 - _gcry_mpi_powm: if (xsize >= base_u_size)
    mpi-pow.c line 573 - _gcry_mpi_powm: MPN_COPY (precomp[i], rp, rsize)
    mpi-pow.c line 577 - _gcry_mpi_powm: MPN_ZERO (base_u, max_u_size)
    mpi-pow.c line 599 - _gcry_mpi_powm: MPN_COPY ( rp, bp, bsize )
    mpi-pow.c line 750 - _gcry_mpi_powm: if ( carry_limb )
    mpi-pow.c line 758 - _gcry_mpi_powm: MPN_COPY (res->d, rp, rsize)
    mpi-pow.c line 762 - _gcry_mpi_powm: if ( rsize >= msize )
    mpi-pow.c line 771 - _gcry_mpi_powm: MPN_NORMALIZE (rp, rsize)
    mpi-pow.c line 780 - _gcry_mpi_powm: if ( negative_result && rsize )
    mpi-pow.c line 787 - _gcry_mpi_powm: MPN_NORMALIZE(rp, rsize)
    mpi-pow.c line 796 - _gcry_mpi_powm: if (bp_marker)
~
*** Commit *65fc715* - O0 Tainted/Untrusted: mod 4, expo 4 - Whitelist: res, rp, rsize
    #+BEGIN_SRC c
    mpi/mpi-pow.c line  371 - if( ssize < KARATSUBA_THRESHOLD ) // FP(?) base_u_size
    mpi/mpi-pow.c line  376 - if (rsize + ssize > msize) // TP Small leak on 
    mpi/mpi-pow.c line  434 - MPN_NORMALIZE(ep, esize); // TP Small leak, changes esize to the first non-zero
    mpi/mpi-pow.c line  478 - if (mod_shift_cnt) // TP small leak 
    mpi/mpi-pow.c line  500 - MPN_NORMALIZE( bp, bsize ); // TP unk - bp tainted from divrem with mod - This is because mpih-div.c not included
    mpi/mpi-pow.c line  523 - if ( rp == ep ) // TP small - ep is data pointer for expo
    mpi/mpi-pow.c line  553 - negative_result = (ep[0] & 1) && bsign; // TP small - short circuit on ep.
    mpi/mpi-pow.c line  563 - if (xsize >= base_u_size) // Possible FP, xsize tainted due to mpih_mul.c not being linked in line  557
    mpi/mpi-pow.c line  571 - if (max_u_size < base_u_size) // same as above
    mpi/mpi-pow.c line  577 - MPN_ZERO (base_u, max_u_size); // same as above, for loop tainted due to missing function sig
    mpi/mpi-pow.c line  609 - if (e == 0) // TP small - directly on expo limb
    mpi/mpi-pow.c line  632 - if (c >= W) // TP > 1 bit - compare leading zeros to window size
    mpi/mpi-pow.c line  657 - for (j += W - c0; j; j--) // TP > 1 bit - loop length depends on 0's in expo 
    mpi/mpi-pow.c line  691 - if (c != 0) // TP > 1 bit, c intially leading zeros, decreased by trailing 0's this is remainder
    mpi/mpi-pow.c line  699 - while (j--) // TP > 1 bit - square based on number of left over + trailing zeros
    mpi/mpi-pow.c line  706 - if (e != 0) // TP small leak - current limb of exponent
    mpi/mpi-pow.c line  732 - for (; c; c--) // TP > 1 bit - c based on trailing zeros in expo
    mpi/mpi-pow.c line  746 - if ( mod_shift_cnt ) // TP small - leading zeros in mod
    mpi/mpi-pow.c line  750 - if ( carry_limb ) // Possible FP, due to missing function signature
    mpi/mpi-pow.c line  769 - if ( mod_shift_cnt ) // TP small - leading zeros in mod
    mpi/mpi-pow.c line  782 - if ( mod_shift_cnt ) // TP small - leading zeros in mod
    #+END_SRC
** mpi-pow.c mpih-mul.c mpih-div.c test   
*** Commit *65fc715* - O0 Tainted/Untrusted: mod 4, expo 4 - Whitelist: res, rp, rsize
    #+BEGIN_SRC c
    mpi/mpih-div.c line  227 - if( n1 >= d ) {
    mpi/mpih-div.c line  233 - for( i = nsize - 2; i >= 0; i--)
    mpi/mpih-div.c line  237 - for( i = qextra_limbs - 1; i >= 0; i-- )
    mpi/mpih-div.c line  256 - if( n1 >= d1 && (n1 > d1 || n0 >= d0) ) {
    mpi/mpih-div.c line  261 - for( i = qextra_limbs + nsize - 2 - 1; i >= 0; i-- ) {
    mpi/mpih-div.c line  265 - if( i >= qextra_limbs )
    mpi/mpih-div.c line  270 - if( n1 == d1 ) {
    mpi/mpih-div.c line  277 - if( r < d1 ) {   /* Carry in the addition? */
    mpi/mpih-div.c line  292 - if( n1 > r || (n1 == r && n0 > n2) ) {
    mpi/mpih-div.c line  297 - if( r >= d1 )    /* If not carry, test Q again.  */
    mpi/mpih-div.c line  319 - if( n0 >= dX ) {
    mpi/mpih-div.c line  320 - if(n0 > dX || _gcry_mpih_cmp(np, dp, dsize - 1) >= 0 ) {
    mpi/mpih-div.c line  327 - for( i = qextra_limbs + nsize - dsize - 1; i >= 0; i--) {
    mpi/mpih-div.c line  332 - if( i >= qextra_limbs ) {
    mpi/mpih-div.c line  342 - if( n0 == dX ) {
    mpi/mpih-div.c line  353 - while( n1 > r || (n1 == r && n0 > np[dsize - 2])) {
    mpi/mpih-div.c line  356 - if( r < dX ) /* I.e. "carry in previous addition?" */
    mpi/mpih-div.c line  368 - if( n2 != cy_limb ) {
    mpi/mpi-pow.c line  371 - if( ssize < KARATSUBA_THRESHOLD )
    mpi/mpi-pow.c line  376 - if (rsize + ssize > msize)
    mpi/mpi-pow.c line  434 - MPN_NORMALIZE(ep, esize);
    mpi/mpi-pow.c line  478 - if (mod_shift_cnt)
    mpi/mpi-pow.c line  523 - if ( rp == ep )
    mpi/mpi-pow.c line  553 - negative_result = (ep[0] & 1) && bsign;
    mpi/mpi-pow.c line  563 - if (xsize >= base_u_size)
    mpi/mpi-pow.c line  571 - if (max_u_size < base_u_size)
    mpi/mpi-pow.c line  577 - MPN_ZERO (base_u, max_u_size);
    mpi/mpi-pow.c line  609 - if (e == 0)
    mpi/mpi-pow.c line  632 - if (c >= W)
    mpi/mpi-pow.c line  657 - for (j += W - c0; j; j--)
    mpi/mpi-pow.c line  691 - if (c != 0)
    mpi/mpi-pow.c line  699 - while (j--)
    mpi/mpi-pow.c line  706 - if (e != 0)
    mpi/mpi-pow.c line  732 - for (; c; c--)
    mpi/mpi-pow.c line  746 - if ( mod_shift_cnt )
    mpi/mpi-pow.c line  750 - if ( carry_limb )
    mpi/mpi-pow.c line  769 - if ( mod_shift_cnt )
    mpi/mpi-pow.c line  782 - if ( mod_shift_cnt )
    mpi/mpih-mul.c line   83 - if( v_limb <= 1 ) {
    mpi/mpih-mul.c line   84 - if( v_limb == 1 )
    mpi/mpih-mul.c line   85 - MPN_COPY( prodp, up, size );
    mpi/mpih-mul.c line   87 - MPN_ZERO( prodp, size );
    mpi/mpih-mul.c line   98 - for( i = 1; i < size; i++ ) {
    mpi/mpih-mul.c line  100 - if( v_limb <= 1 ) {
    mpi/mpih-mul.c line  102 - if( v_limb == 1 )
    mpi/mpih-mul.c line  120 - if( size & 1 ) {
    mpi/mpih-mul.c line  134 - MPN_MUL_N_RECURSE( prodp, up, vp, esize, tspace );
    mpi/mpih-mul.c line  165 - MPN_MUL_N_RECURSE(prodp + size, up + hsize, vp + hsize, hsize, tspace);
    mpi/mpih-mul.c line  170 - if( _gcry_mpih_cmp(up + hsize, up, hsize) >= 0 ) {
    mpi/mpih-mul.c line  178 - if( _gcry_mpih_cmp(vp + hsize, vp, hsize) >= 0 ) {
    mpi/mpih-mul.c line  190 - MPN_MUL_N_RECURSE(tspace, prodp, prodp + hsize, hsize, tspace + size);
    mpi/mpih-mul.c line  193 - MPN_COPY (prodp + hsize, prodp + size, hsize);
    mpi/mpih-mul.c line  209 - MPN_MUL_N_RECURSE(tspace, up, vp, hsize, tspace + size);
    mpi/mpih-mul.c line  214 - if( cy )
    mpi/mpih-mul.c line  217 - MPN_COPY(prodp, tspace, hsize);
    mpi/mpih-mul.c line  219 - if( cy )
    mpi/mpih-mul.c line  385 - if( !ctx->tspace || ctx->tspace_size < vsize ) {
    mpi/mpih-mul.c line  386 - if( ctx->tspace )
    mpi/mpih-mul.c line  389 - ctx->tspace = mpi_alloc_limb_space (2 * vsize,
    mpi/mpih-mul.c line  395 - MPN_MUL_N_RECURSE( prodp, up, vp, vsize, ctx->tspace );
    mpi/mpih-mul.c line  400 - if( usize >= vsize ) {
    mpi/mpih-mul.c line  401 - if( !ctx->tp || ctx->tp_size < vsize ) {
    mpi/mpih-mul.c line  402 - if( ctx->tp )
    mpi/mpih-mul.c line  405 - ctx->tp = mpi_alloc_limb_space (2 * vsize,
    mpi/mpih-mul.c line  412 - MPN_MUL_N_RECURSE( ctx->tp, up, vp, vsize, ctx->tspace );
    mpi/mpih-mul.c line  418 - } while( usize >= vsize );
    mpi/mpih-mul.c line  421 - if( usize ) {
    mpi/mpih-mul.c line  422 - if( usize < KARATSUBA_THRESHOLD ) {
    mpi/mpih-mul.c line  426 - if( !ctx->next ) {
    mpi/mpih-mul.c line  446 - if( ctx->tp )
    mpi/mpih-mul.c line  448 - if( ctx->tspace )
    mpi/mpih-mul.c line  450 - for( ctx=ctx->next; ctx; ctx = ctx2 ) {
    mpi/mpih-mul.c line  452 - if( ctx->tp )
    mpi/mpih-mul.c line  454 - if( ctx->tspace )
    mpi/mpih-mul.c line  483 - if( vsize < KARATSUBA_THRESHOLD ) {
    mpi/mpih-mul.c line  487 - if( !vsize )
    mpi/mpih-mul.c line  493 - if( v_limb <= 1 ) {
    mpi/mpih-mul.c line  494 - if( v_limb == 1 )
    mpi/mpih-mul.c line  495 - MPN_COPY( prodp, up, usize );
    mpi/mpih-mul.c line  497 - MPN_ZERO( prodp, usize );
    mpi/mpih-mul.c line  508 - for( i = 1; i < vsize; i++ ) {
    mpi/mpih-mul.c line  510 - if( v_limb <= 1 ) {
    mpi/mpih-mul.c line  512 - if( v_limb == 1 )
    #+END_SRC
    
* LibGcrypt 1.8.2
** mpi-pow.c 
*** Commit *e54a398*
   Tainted/Untrusted: mod 4, expo 4
   Whitelist: res, rp, rsize
   
   
   Results
  #+BEGIN_SRC c
RL  mpi/mpi-pow.c line  377 - if( ssize < KARATSUBA_THRESHOLD )
RL  mpi/mpi-pow.c line  382 - if (rsize + ssize > msize)
RL  mpi/mpi-pow.c line  440 - MPN_NORMALIZE(ep, esize); // Leaks length of `expo`
UL  mpi/mpi-pow.c line  484 - if (mod_shift_cnt) // Leaks leading zeros of `mod`
RL  mpi/mpi-pow.c line  506 - MPN_NORMALIZE( bp, bsize ); // Leaks length of `base`, but `base` length <= `mod` length
FP  mpi/mpi-pow.c line  529 - if ( rp == ep ) // Pointer comparison 
UL  mpi/mpi-pow.c line  559 - negative_result = (ep[0] & 1) && bsign; // Leaks information about first limb of `expo`
RL  mpi/mpi-pow.c line  569 - if (xsize >= base_u_size) // Leaks information about `mod` size from msize->bsize
RL  mpi/mpi-pow.c line  577 - if (max_u_size < base_u_size) // Leaks information about `mod` size from msize->bsize
UL  mpi/mpi-pow.c line  582 - if (msize > max_u_size) // Leaks information about `mod` size
RL  mpi/mpi-pow.c line  585 - MPN_ZERO (base_u, max_u_size); // False positive?
RH  mpi/mpi-pow.c line  617 - if (e == 0) // Repeated branch - directy on `expo` data
RH  mpi/mpi-pow.c line  641 - if (c >= W) // Repeated branch - c is leading zeros for current `expo` limb
RH  mpi/mpi-pow.c line  667 - for (j += W - c0; j >= 0; j--) // Nested Loop branches on data derived from `expo`
RH  mpi/mpi-pow.c line  702 - while (j--) // Loop branched on value computed from last limb of `expo`
UL  mpi/mpi-pow.c line  715 - if ( mod_shift_cnt ) // Single branch derived from `mod`
UL  mpi/mpi-pow.c line  719 - if ( carry_limb ) // Tainted result from lshift calculation
UL  mpi/mpi-pow.c line  738 - if ( mod_shift_cnt ) // Branch on result rshift calculation
UL  mpi/mpi-pow.c line  751 - if ( mod_shift_cnt ) // Nested branch based on first limb of `expo`. 
  #+END_SRC
  
**** Classification
    | Err. Type        | Qty | Comments                                                      |
    | False Positive   |   1 |                                                               |
    | Validation       |   0 |                                                               |
    | Looped Branch    |  11 |                                                               |
    | Un-looped Branch |   7 |                                                               |
    | High entropy     |  15 | The high entropy results are mostly on size of various inputs |
    | Low entropy      |   3 | All of the low entropy results are on looped branches         |
    | Total Reported   |  19 |                                                               |

*** Commit *d47280a59f*
**** No Whitelist
    Tainted/Untrusted: mod 4, expo 4
    Whitelist: 
    
    #+BEGIN_SRC c
RL    mpi/mpi-pow.c line  377 - if( ssize < KARATSUBA_THRESHOLD )
RL    mpi/mpi-pow.c line  382 - if (rsize + ssize > msize)
UL    mpi/mpi-pow.c line  440 - MPN_NORMALIZE(ep, esize);
UL    mpi/mpi-pow.c line  467 - if (res->nlimbs)
UL    mpi/mpi-pow.c line  469 - RESIZE_IF_NEEDED (res, 1);
UL    mpi/mpi-pow.c line  484 - if (mod_shift_cnt)
UL    mpi/mpi-pow.c line  506 - MPN_NORMALIZE( bp, bsize );
FP    mpi/mpi-pow.c line  521 - if ( rp == bp )
FP    mpi/mpi-pow.c line  529 - if ( rp == ep )
UL    mpi/mpi-pow.c line  538 - if (res->alloced < size)
UL    mpi/mpi-pow.c line  559 - negative_result = (ep[0] & 1) && bsign;
RL    mpi/mpi-pow.c line  569 - if (xsize >= base_u_size)
RL    mpi/mpi-pow.c line  577 - if (max_u_size < base_u_size)
UL    mpi/mpi-pow.c line  579 - MPN_COPY (precomp[i], rp, rsize);
UL    mpi/mpi-pow.c line  582 - if (msize > max_u_size)
UL    mpi/mpi-pow.c line  585 - MPN_ZERO (base_u, max_u_size);
UL    mpi/mpi-pow.c line  605 - MPN_ZERO (rp, rsize);
RH    mpi/mpi-pow.c line  617 - if (e == 0)
RH    mpi/mpi-pow.c line  641 - if (c >= W)
RH    mpi/mpi-pow.c line  667 - for (j += W - c0; j >= 0; j--)
RH    mpi/mpi-pow.c line  702 - while (j--)
UL    mpi/mpi-pow.c line  715 - if ( mod_shift_cnt )
UL    mpi/mpi-pow.c line  719 - if ( carry_limb )
UL    mpi/mpi-pow.c line  725 - else if (res->d != rp)
UL    mpi/mpi-pow.c line  727 - MPN_COPY (res->d, rp, rsize);
UL    mpi/mpi-pow.c line  731 - if ( rsize >= msize )
UL    mpi/mpi-pow.c line  738 - if ( mod_shift_cnt )
UL    mpi/mpi-pow.c line  740 - MPN_NORMALIZE (rp, rsize);
UL    mpi/mpi-pow.c line  749 - if ( negative_result && rsize )
UL    mpi/mpi-pow.c line  751 - if ( mod_shift_cnt )
UL    mpi/mpi-pow.c line  756 - MPN_NORMALIZE(rp, rsize);
VL    mpi/mpi-pow.c line  758 - gcry_assert (res->d == rp);
     #+END_SRC 
    
**** With whitelist
     Tainted/Untrusted: mod 4, expo 4
     Whitelist: esize, msize, xsize, base_u_size, res
     
     #+BEGIN_SRC c
FP      mpi/mpi-pow.c line  529 - if ( rp == ep )
RH      mpi/mpi-pow.c line  617 - if (e == 0)
RH      mpi/mpi-pow.c line  641 - if (c >= W)
RH      mpi/mpi-pow.c line  667 - for (j += W - c0; j >= 0; j--)
RH      mpi/mpi-pow.c line  702 - while (j--)
UL      mpi/mpi-pow.c line  440 - MPN_NORMALIZE(ep, esize);
UL      mpi/mpi-pow.c line  484 - if (mod_shift_cnt)
UL      mpi/mpi-pow.c line  506 - MPN_NORMALIZE( bp, bsize );
UL      mpi/mpi-pow.c line  559 - negative_result = (ep[0] & 1) && bsign;
UL      mpi/mpi-pow.c line  715 - if ( mod_shift_cnt )
UL      mpi/mpi-pow.c line  719 - if ( carry_limb )
UL      mpi/mpi-pow.c line  738 - if ( mod_shift_cnt )
UL      mpi/mpi-pow.c line  740 - MPN_NORMALIZE (rp, rsize);
UL      mpi/mpi-pow.c line  751 - if ( mod_shift_cnt )
UL      mpi/mpi-pow.c line  756 - MPN_NORMALIZE(rp, rsize);
     #+END_SRC 
     
* BearSSL 0.5
** i32_modpow.c
   Tainted/Untrusted: e, m
   Whitelist: 
   
   No Results
** i32_modpow.c i32_montmul.c
   Tainted/Untrusted: e, m
   Whitelist: 
   
   No Results
   #+BEGIN_SRC c
    i32_montmul.c line   38 - for (u = 0; u < len; u ++) {
    i32_montmul.c line   46 - for (v = 0; v < len; v ++) {
   #+END_SRC 
   
** i32_modpow.c i32_montmul.c i32_tmont.c
   Tainted/Untrusted: e, m
   Whitelist: 
   
   3 Results
   #+BEGIN_SRC c
    i32_montmul.c line   38 - for (u = 0; u < len; u ++) {
    i32_montmul.c line   46 - for (v = 0; v < len; v ++) {
    i32_tmont.c line   33 - for (k = (m[0] + 31) >> 5; k > 0; k --) {
   #+END_SRC 
   
** i32 - complete library
   Tainted/Untrusted: e, m
   Whitelist:
   
   24 Results
   #+BEGIN_SRC c
    include/inner.h line 1018 - if (j == 0) {
    i32_montmul.c line   38 - for (u = 0; u < len; u ++) {
    i32_montmul.c line   46 - for (v = 0; v < len; v ++) {
    i32_fmont.c line   34 - for (u = 0; u < len; u ++) {
    i32_fmont.c line   40 - for (v = 0; v < len; v ++) {
    i32_muladd.c line   42 - if (m_bitlen == 0) {
    i32_muladd.c line   45 - if (m_bitlen <= 32) {
    i32_muladd.c line  108 - for (u = 1; u <= mlen; u ++) {
    i32_decred.c line   41 - if (m_bitlen == 0) {
    i32_decred.c line   62 - if (k >= len) {
    i32_decred.c line   82 - if (q > len) {
    i32_decred.c line   89 - if (q <= len) {
    i32_decred.c line  104 - for (k = len - q; k < len; k += 4) {
    ghi32_decode.c line   38 - if (u < 4) {
    i32_decode.c line   41 - if (u < 2) {
    i32_decode.c line   42 - if (u == 0) {
    i32_decode.c line   48 - if (u == 2) {
    i32_sub.c line   36 - for (u = 1; u < m; u ++) {
    i32_add.c line   36 - for (u = 1; u < m; u ++) {
    i32_tmont.c line   33 - for (k = (m[0] + 31) >> 5; k > 0; k --) {
    i32_reduce.c line   38 - if (m_bitlen == 0) {
    i32_reduce.c line   48 - if (a_bitlen < m_bitlen) {
    i32_reduce.c line   50 - for (u = alen; u < mlen; u ++) {
    i32_reduce.c line   63 - for (u = 1 + alen - mlen; u > 0; u --) {
   #+END_SRC
   
** i32 - complete library entry at br_i32_modpow
   Tainted/Untrusted: e, m
   Whitelist: 
   
   9 Results
   #+BEGIN_SRC c
   include/inner.h line 1018 - if (j == 0) { // Speeds up 0 offset case :  br_i32_word returns word at offset from ptr
   i32_montmul.c line   38 - for (u = 0; u < len; u ++) { // Constant time `len` is calculated from modulus length
   i32_montmul.c line   46 - for (v = 0; v < len; v ++) { // Constant time `len` is calculated from modulus length
   i32_muladd.c line   42 - if (m_bitlen == 0) { // Error Check `mbitlen` calulated from modulus length
   i32_muladd.c line   45 - if (m_bitlen <= 32) { // Leak on modulus length
   i32_muladd.c line  108 - for (u = 1; u <= mlen; u ++) {  // Constant time on `mlen` modulus length
   i32_sub.c line   36 - for (u = 1; u < m; u ++) { // Constant time `m` is leaked length of 1st sub operand
   i32_add.c line   36 - for (u = 1; u < m; u ++) { // Constant time `m` is leaked length of 1st add operand
   i32_tmont.c line   33 - for (k = (m[0] + 31) >> 5; k > 0; k --) {
   #+END_SRC
   
** i32 - complete including cond copy
*** Test with whitelist
   Tainted/Untrusted: e, m
   Whitelist: mlen, m_bitlen, len
   entry at br_i32_modpow
   
   3 Results
   #+BEGIN_SRC c
    i32_sub.c line   36 - for (u = 1; u < m; u ++) {
    i32_add.c line   36 - for (u = 1; u < m; u ++) {
    i32_tmont.c line   33 - for (k = (m[0] + 31) >> 5; k > 0; k --) {
   #+END_SRC
   Each of these results are false positives. The files i32_sub and i32_add use `m` for a len variable
   the file i32_tmont calculates k from public value of `m`. m[0] + 31 is a known accepted leak.
   
**** Classification
    | Err. Type        | Qty | Comments                                                               |
    | False Positive   |   3 | Due to aliasing between m for mod and m for length in different scopes |
    | Validation       |   0 | Bear uses primitive types so not much error checking is done           |
    | Looped Branch    |   0 | The 3 reported results are looped branches but are false positives     |
    | Un-looped Branch |   0 | None Reported                                                          |
    | High Entropy     |   3 | M is just a length                                                     |
    | Low Entropy      |   0 |                                                                        |
    | Total            |   3 |                                                                        |

*** i32 - complete w/ ccopy no-whitelist
   Commit *d47280a59f*
   Tainted/Untrusted: e @ br_i32_modpow, m @ br_i32_modpow
   Whitelist: 
   Entry: br_i32_modpow
   
   #+BEGIN_SRC c
UL  include/inner.h line 1018 - if (j == 0) {
RL  i32_montmul.c line   38 - for (u = 0; u < len; u ++) {
RL  i32_montmul.c line   46 - for (v = 0; v < len; v ++) {
RL  i32_muladd.c line   42 - if (m_bitlen == 0) {
RL  i32_muladd.c line   45 - if (m_bitlen <= 32) {
RL  i32_muladd.c line  108 - for (u = 1; u <= mlen; u ++) {
RL  i32_sub.c line   36 - for (u = 1; u < m; u ++) {
RL  i32_add.c line   36 - for (u = 1; u < m; u ++) {
RL  i32_tmont.c line   33 - for (k = (m[0] + 31) >> 5; k > 0; k --) {
RL  ccopy.c line   36 - while (len -- > 0) {
   #+END_SRC
   
*** i32 - complete w/ ccopy and whitelist
    Commit *d47280a59f*
    Tainted/Untrusted: e @ br_i32_modpow, m @ br_i32_modpow
    Whitelist: m_bitlen, mlen, len
    Entry: br_i32_modpow
    
    #+BEGIN_SRC c
RL    i32_sub.c line   36 - for (u = 1; u < m; u ++) {
RL    i32_add.c line   36 - for (u = 1; u < m; u ++) {
RL    i32_tmont.c line   33 - for (k = (m[0] + 31) >> 5; k > 0; k --) {
    #+END_SRC
    
* mbedTLS 
** rsa.c bignum.c
   Commit *65fc715*
   Tainted: P, Q, D
   Untrusted: input
   Whitelist wbits, wsize, N, E
   
   #+BEGIN_SRC c
    rsa.c line  166 - MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->P, ( nbits + 1 ) >> 1, 0,
    rsa.c line  169 - MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->Q, ( nbits + 1 ) >> 1, 0,
    rsa.c line  206 - if( ret != 0 )
    rsa.c line  225 - if( ( ctx->N.p[0] & 1 ) == 0 ||
    rsa.c line  393 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
    rsa.c line  439 - MBEDTLS_MPI_CHK( rsa_prepare_blinding( ctx, f_rng, p_rng ) );
    rsa.c line  491 - if( ret != 0 )
    rsa.c line  525 - while( dlen > 0 )
    rsa.c line  528 - if( dlen < hlen )
    rsa.c line  536 - for( i = 0; i < use_len; ++i )
    rsa.c line  588 - if( ( ret = f_rng( p_rng, p, hlen ) ) != 0 )
    rsa.c line  661 - } while( *p == 0 && --rng_dl && ret == 0 );
    rsa.c line  665 - if( rng_dl == 0 || ret != 0 )
    rsa.c line  762 - if( ret != 0 )
    rsa.c line  819 - if( bad != 0 )
    rsa.c line  822 - if( ilen - ( p - buf ) > output_max_len )
    rsa.c line  861 - if( ret != 0 )
    rsa.c line  904 - if( bad )
    rsa.c line  907 - if( ilen - ( p - buf ) > output_max_len )
    rsa.c line 1003 - if( ( ret = f_rng( p_rng, salt, slen ) ) != 0 )
    rsa.c line 1085 - if( mbedtls_oid_get_oid_by_md( md_alg, &oid, &oid_size ) != 0 )
    rsa.c line 1095 - if( ( nb_pad < 8 ) || ( nb_pad > olen ) )
    rsa.c line 1146 - MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );
    rsa.c line 1154 - if( diff_no_optimize != 0 )
    rsa.c line 1239 - if( ret != 0 )
    rsa.c line 1244 - if( buf[siglen - 1] != 0xBC )
    rsa.c line 1278 - if( buf[0] >> ( 8 - siglen * 8 + msb ) )
    rsa.c line 1288 - while( p < buf + siglen && *p == 0 )
    rsa.c line 1291 - if( p == buf + siglen ||
    rsa.c line 1381 - if( ret != 0 )
    rsa.c line 1673 - if( mbedtls_rsa_pkcs1_encrypt( &rsa, myrand, NULL, MBEDTLS_RSA_PUBLIC, PT_LEN,
    rsa.c line 1685 - if( mbedtls_rsa_pkcs1_decrypt( &rsa, myrand, NULL, MBEDTLS_RSA_PRIVATE, &len,
    rsa.c line 1712 - if( mbedtls_rsa_pkcs1_sign( &rsa, myrand, NULL, MBEDTLS_RSA_PRIVATE, MBEDTLS_MD_SHA1, 0,
    rsa.c line 1724 - if( mbedtls_rsa_pkcs1_verify( &rsa, NULL, NULL, MBEDTLS_RSA_PUBLIC, MBEDTLS_MD_SHA1, 0,
    bignum.c line  154 - if( X->p[i] != 0 )
    bignum.c line  195 - if( Y->p[i] != 0 )
    bignum.c line  353 - if( ( ( X->p[i] >> j ) & 1 ) != 0 )
    bignum.c line  369 - if( x & mask ) break;
    bignum.c line  388 - if( X->p[i] != 0 )
    bignum.c line  510 - if( r < 10 )
    bignum.c line  656 - if( fwrite( p, 1, plen, fout ) != plen ||
    bignum.c line  678 - if( buf[n] != 0 )
    bignum.c line  813 - if( X->p[i - 1] != 0 )
    bignum.c line  817 - if( Y->p[j - 1] != 0 )
    bignum.c line  828 - if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
    bignum.c line  829 - if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
    bignum.c line  843 - if( X->p[i - 1] != 0 )
    bignum.c line  847 - if( Y->p[j - 1] != 0 )
    bignum.c line  861 - if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
    bignum.c line  862 - if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
    bignum.c line  907 - if( B->p[j - 1] != 0 )
    bignum.c line  924 - while( c != 0 )
    bignum.c line  954 - while( c != 0 )
    bignum.c line  992 - if( B->p[n - 1] != 0 )
    bignum.c line 1166 - }
    bignum.c line 1185 - if( A->p[i - 1] != 0 )
    bignum.c line 1189 - if( B->p[j - 1] != 0 )
    bignum.c line 1243 - if( 0 == d || u1 >= d )
    bignum.c line 1254 - if( quotient > ( (mbedtls_t_udbl) 1 << biL ) - 1 )
    bignum.c line 1372 - if( X.p[i] >= Y.p[t] )
    bignum.c line 1522 - if( A->s < 0 && y != 0 )
    bignum.c line 1617 - if( mbedtls_mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
    bignum.c line 1736 - if( ei == 0 && state == 0 )
    bignum.c line 1739 - if( ei == 0 && state == 1 )
    bignum.c line 1793 - if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
    bignum.c line 1881 - MBEDTLS_MPI_CHK( f_rng( p_rng, buf, size ) );
    bignum.c line 1923 - while( ( TU.p[0] & 1 ) == 0 )
    bignum.c line 1927 - if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
    bignum.c line 1937 - while( ( TV.p[0] & 1 ) == 0 )
    bignum.c line 1941 - if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
    bignum.c line 2025 - if( ( X->p[0] & 1 ) == 0 )
    bignum.c line 2035 - if( r == 0 )
    bignum.c line 2079 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
    bignum.c line 2090 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
    bignum.c line 2198 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
    bignum.c line 2209 - while( ( ret = mbedtls_mpi_is_prime( X, f_rng, p_rng ) ) != 0 )
    bignum.c line 2211 - if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
    bignum.c line 2228 - if( r == 0 )
    bignum.c line 2230 - else if( r == 1 )
    bignum.c line 2243 - if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
    bignum.c line 2245 - ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
    bignum.c line 2251 - if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
   #+END_SRC
   
** bignum.c
   Commit *45dd977574*
   Tainted: N, E
   Untrusted: N, E
   
   189 Results
   #+BEGIN_SRC c
    bignum.c line   63 - volatile mbedtls_mpi_uint *p = v; while( n-- ) *p++ = 0;
    bignum.c line   84 - if( X == NULL )
    bignum.c line   97 - if( X == NULL )
    bignum.c line  100 - if( X->p != NULL )
    bignum.c line  118 - if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
    bignum.c line  121 - if( X->n < nblimbs )
    bignum.c line  123 - if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
    bignum.c line  126 - if( X->p != NULL )
    bignum.c line  150 - if( X->n <= nblimbs )
    bignum.c line  153 - for( i = X->n - 1; i > 0; i-- )
    bignum.c line  154 - if( X->p[i] != 0 )
    bignum.c line  158 - if( i < nblimbs )
    bignum.c line  161 - if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( i, ciL ) ) == NULL )
    bignum.c line  164 - if( X->p != NULL )
    bignum.c line  185 - if( X == Y )
    bignum.c line  188 - if( Y->p == NULL )
    bignum.c line  194 - for( i = Y->n - 1; i > 0; i-- )
    bignum.c line  195 - if( Y->p[i] != 0 )
    bignum.c line  243 - for( ; i < X->n; i++ )
    bignum.c line  276 - for( i = 0; i < X->n; i++ )
    bignum.c line  328 - if( X->n * biL <= pos )
    bignum.c line  351 - for( i = 0; i < X->n; i++ )
    bignum.c line  353 - if( ( ( X->p[i] >> j ) & 1 ) != 0 )
    bignum.c line  369 - if( x & mask ) break;
    bignum.c line  384 - if( X->n == 0 )
    bignum.c line  387 - for( i = X->n - 1; i > 0; i-- )
    bignum.c line  388 - if( X->p[i] != 0 )
    bignum.c line  475 - if( X->s == 1 )
    bignum.c line  507 - if( mbedtls_mpi_cmp_int( X, 0 ) != 0 )
    bignum.c line  510 - if( r < 10 )
    bignum.c line  544 - if( buflen < n )
    bignum.c line  553 - if( X->s == -1 )
    bignum.c line  561 - for( i = X->n, k = 0; i > 0; i-- )
    bignum.c line  567 - if( c == 0 && k == 0 && ( i + j ) != 2 )
    bignum.c line  580 - if( T.s == -1 )
    bignum.c line  656 - if( fwrite( p, 1, plen, fout ) != plen ||
    bignum.c line  677 - for( n = 0; n < buflen; n++ )
    bignum.c line  678 - if( buf[n] != 0 )
    bignum.c line  684 - for( i = buflen, j = 0; i > n; i--, j++ )
    bignum.c line  701 - if( buflen < n )
    bignum.c line  706 - for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
    bignum.c line  726 - if( X->n * biL < i )
    bignum.c line  734 - if( v0 > 0 )
    bignum.c line  736 - for( i = X->n; i > v0; i-- )
    bignum.c line  739 - for( ; i > 0; i-- )
    bignum.c line  746 - if( t1 > 0 )
    bignum.c line  748 - for( i = v0; i < X->n; i++ )
    bignum.c line  773 - if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
    bignum.c line  779 - if( v0 > 0 )
    bignum.c line  781 - for( i = 0; i < X->n - v0; i++ )
    bignum.c line  784 - for( ; i < X->n; i++ )
    bignum.c line  791 - if( v1 > 0 )
    bignum.c line  793 - for( i = X->n; i > 0; i-- )
    bignum.c line  812 - for( i = X->n; i > 0; i-- )
    bignum.c line  813 - if( X->p[i - 1] != 0 )
    bignum.c line  816 - for( j = Y->n; j > 0; j-- )
    bignum.c line  817 - if( Y->p[j - 1] != 0 )
    bignum.c line  820 - if( i == 0 && j == 0 )
    bignum.c line  823 - if( i > j ) return(  1 );
    bignum.c line  824 - if( j > i ) return( -1 );
    bignum.c line  826 - for( ; i > 0; i-- )
    bignum.c line  828 - if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
    bignum.c line  829 - if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
    bignum.c line  842 - for( i = X->n; i > 0; i-- )
    bignum.c line  843 - if( X->p[i - 1] != 0 )
    bignum.c line  846 - for( j = Y->n; j > 0; j-- )
    bignum.c line  847 - if( Y->p[j - 1] != 0 )
    bignum.c line  850 - if( i == 0 && j == 0 )
    bignum.c line  853 - if( i > j ) return(  X->s );
    bignum.c line  854 - if( j > i ) return( -Y->s );
    bignum.c line  856 - if( X->s > 0 && Y->s < 0 ) return(  1 );
    bignum.c line  857 - if( Y->s > 0 && X->s < 0 ) return( -1 );
    bignum.c line  859 - for( ; i > 0; i-- )
    bignum.c line  861 - if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
    bignum.c line  862 - if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
    bignum.c line  893 - if( X == B )
    bignum.c line  898 - if( X != A )
    bignum.c line  906 - for( j = B->n; j > 0; j-- )
    bignum.c line  907 - if( B->p[j - 1] != 0 )
    bignum.c line  917 - for( i = 0; i < j; i++, o++, p++ )
    bignum.c line  924 - while( c != 0 )
    bignum.c line  926 - if( i >= X->n )
    bignum.c line  948 - for( i = c = 0; i < n; i++, s++, d++ )
    bignum.c line  954 - while( c != 0 )
    bignum.c line  975 - if( X == B )
    bignum.c line  981 - if( X != A )
    bignum.c line  991 - for( n = B->n; n > 0; n-- )
    bignum.c line  992 - if( B->p[n - 1] != 0 )
    bignum.c line 1011 - if( A->s * B->s < 0 )
    bignum.c line 1042 - if( A->s * B->s > 0 )
    bignum.c line 1128 - for( ; i >= 16; i -= 16 )
    bignum.c line 1143 - for( ; i >= 8; i -= 8 )
    bignum.c line 1154 - for( ; i > 0; i-- )
    bignum.c line 1166 - }
    bignum.c line 1181 - if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
    bignum.c line 1182 - if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
    bignum.c line 1184 - for( i = A->n; i > 0; i-- )
    bignum.c line 1185 - if( A->p[i - 1] != 0 )
    bignum.c line 1188 - for( j = B->n; j > 0; j-- )
    bignum.c line 1189 - if( B->p[j - 1] != 0 )
    bignum.c line 1195 - for( i++; j > 0; j-- )
    bignum.c line 1243 - if( 0 == d || u1 >= d )
    bignum.c line 1254 - if( quotient > ( (mbedtls_t_udbl) 1 << biL ) - 1 )
    bignum.c line 1328 - if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
    bignum.c line 1351 - if( k < biL - 1 )
    bignum.c line 1363 - while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
    bignum.c line 1370 - for( i = n; i > t ; i-- )
    bignum.c line 1372 - if( X.p[i] >= Y.p[t] )
    bignum.c line 1386 - T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
    bignum.c line 1391 - T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
    bignum.c line 1392 - T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
    bignum.c line 1394 - }
    bignum.c line 1401 - if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
    bignum.c line 1422 - if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
    bignum.c line 1457 - if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
    bignum.c line 1462 - while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
    bignum.c line 1465 - while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
    bignum.c line 1505 - for( i = A->n, y = 0; i > 0; i-- )
    bignum.c line 1522 - if( A->s < 0 && y != 0 )
    bignum.c line 1556 - if( T->n < N->n + 1 || T->p == NULL )
    bignum.c line 1563 - m = ( B->n < n ) ? B->n : n;
    bignum.c line 1565 - for( i = 0; i < n; i++ )
    bignum.c line 1617 - if( mbedtls_mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
    bignum.c line 1620 - if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
    bignum.c line 1633 - wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
    bignum.c line 1634 - ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
    bignum.c line 1636 - if( wsize > MBEDTLS_MPI_WINDOW_SIZE )
    bignum.c line 1648 - if( neg )
    bignum.c line 1658 - if( _RR == NULL || _RR->p == NULL )
    bignum.c line 1673 - if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
    bignum.c line 1686 - if( wsize > 1 )
    bignum.c line 1696 - for( i = 0; i < wsize - 1; i++ )
    bignum.c line 1702 - for( i = j + 1; i < ( one << wsize ); i++ )
    bignum.c line 1721 - if( nblimbs == 0 )
    bignum.c line 1736 - if( ei == 0 && state == 0 )
    bignum.c line 1739 - if( ei == 0 && state == 1 )
    bignum.c line 1756 - if( nbits == wsize )
    bignum.c line 1761 - for( i = 0; i < wsize; i++ )
    bignum.c line 1778 - for( i = 0; i < nbits; i++ )
    bignum.c line 1784 - if( ( wbits & ( one << wsize ) ) != 0 )
    bignum.c line 1793 - if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
    bignum.c line 1801 - for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
    bignum.c line 1806 - if( _RR == NULL || _RR->p == NULL )
    bignum.c line 1837 - while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
    bignum.c line 1842 - if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
    bignum.c line 1878 - if( size > MBEDTLS_MPI_MAX_SIZE )
    bignum.c line 1881 - MBEDTLS_MPI_CHK( f_rng( p_rng, buf, size ) );
    bignum.c line 1896 - if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
    bignum.c line 1905 - if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
    bignum.c line 1923 - while( ( TU.p[0] & 1 ) == 0 )
    bignum.c line 1927 - if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
    bignum.c line 1937 - while( ( TV.p[0] & 1 ) == 0 )
    bignum.c line 1941 - if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
    bignum.c line 1951 - if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
    bignum.c line 1963 - }
    bignum.c line 1966 - while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
    bignum.c line 1969 - while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
    bignum.c line 2025 - if( ( X->p[0] & 1 ) == 0 )
    bignum.c line 2030 - if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
    bignum.c line 2035 - if( r == 0 )
    bignum.c line 2070 - n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
    bignum.c line 2071 - ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
    bignum.c line 2072 - ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );
    bignum.c line 2074 - for( i = 0; i < n; i++ )
    bignum.c line 2079 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
    bignum.c line 2081 - if( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 )
    bignum.c line 2090 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
    bignum.c line 2094 - if (j > k) {
    bignum.c line 2102 - } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
    bignum.c line 2110 - if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
    bignum.c line 2115 - while( j < s && mbedtls_mpi_cmp_mpi( &A, &W ) != 0 )
    bignum.c line 2123 - if( mbedtls_mpi_cmp_int( &A, 1 ) == 0 )
    bignum.c line 2132 - if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
    bignum.c line 2161 - if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
    bignum.c line 2165 - if( mbedtls_mpi_cmp_int( &XX, 2 ) == 0 )
    bignum.c line 2198 - MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
    bignum.c line 2201 - if( k > nbits ) MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( X, k - nbits + 1 ) );
    bignum.c line 2209 - while( ( ret = mbedtls_mpi_is_prime( X, f_rng, p_rng ) ) != 0 )
    bignum.c line 2211 - if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
    bignum.c line 2228 - if( r == 0 )
    bignum.c line 2230 - else if( r == 1 )
    bignum.c line 2243 - if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
    bignum.c line 2245 - ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
    bignum.c line 2251 - if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
    bignum.c line 2326 - if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
    bignum.c line 2351 - if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 ||
    bignum.c line 2374 - if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
    bignum.c line 2396 - if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
    bignum.c line 2418 - if( mbedtls_mpi_cmp_int( &A, gcd_pairs[i][2] ) != 0 )
   #+END_SRC
   
** bignum.c
   Commit *45dd977574*
   Tainted: N, E
   Untrusted: N, E
   Entry: mbedtls_mpi_exp_mod
   
   #+BEGIN_SRC c
     /* mbedtls_mpi_zeroize */
     bignum.c line   63 - volatile mbedtls_mpi_uint *p = v; while( n-- ) *p++ = 0;
     /* mbedtls_mpi_free */
     bignum.c line   97 - if( X == NULL )
     bignum.c line  100 - if( X->p != NULL )

     /* mbedtls_mpi_grow */
     bignum.c line  118 - if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
     bignum.c line  121 - if( X->n < nblimbs )
     bignum.c line  123 - if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
     bignum.c line  126 - if( X->p != NULL )

     /* mbedtls_mpi_copy */
     bignum.c line  185 - if( X == Y )
     bignum.c line  188 - if( Y->p == NULL )
     bignum.c line  194 - for( i = Y->n - 1; i > 0; i-- )
     bignum.c line  195 - if( Y->p[i] != 0 )

     /* mbedtls_clz */
     bignum.c line  369 - if( x & mask ) break;

     /* mbedtls_mpi_bitlen */
     bignum.c line  384 - if( X->n == 0 )
     bignum.c line  387 - for( i = X->n - 1; i > 0; i-- )
     bignum.c line  388 - if( X->p[i] != 0 )

     /* mbedtls_mpi_shift_l */
     bignum.c line  726 - if( X->n * biL < i )
     bignum.c line  734 - if( v0 > 0 )
     bignum.c line  736 - for( i = X->n; i > v0; i-- )
     bignum.c line  739 - for( ; i > 0; i-- )
     bignum.c line  746 - if( t1 > 0 )
     bignum.c line  748 - for( i = v0; i < X->n; i++ )

     /* mbedtls_mpi_shift_r */
     bignum.c line  773 - if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
     bignum.c line  779 - if( v0 > 0 )
     bignum.c line  781 - for( i = 0; i < X->n - v0; i++ )
     bignum.c line  784 - for( ; i < X->n; i++ )
     bignum.c line  791 - if( v1 > 0 )
     bignum.c line  793 - for( i = X->n; i > 0; i-- )

     /* mbedtls_mpi_cmp_abs  return 1 0 -1 */
     bignum.c line  812 - for( i = X->n; i > 0; i-- )
     bignum.c line  813 - if( X->p[i - 1] != 0 )
     bignum.c line  816 - for( j = Y->n; j > 0; j-- )
     bignum.c line  817 - if( Y->p[j - 1] != 0 )
     bignum.c line  820 - if( i == 0 && j == 0 )
     bignum.c line  823 - if( i > j ) return(  1 );
     bignum.c line  824 - if( j > i ) return( -1 );
     bignum.c line  826 - for( ; i > 0; i-- )
     bignum.c line  828 - if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
     bignum.c line  829 - if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );

     /* mbedtls_mpi_cmp_mpi */
     bignum.c line  842 - for( i = X->n; i > 0; i-- )
     bignum.c line  843 - if( X->p[i - 1] != 0 )
     bignum.c line  846 - for( j = Y->n; j > 0; j-- )
     bignum.c line  847 - if( Y->p[j - 1] != 0 )
     bignum.c line  850 - if( i == 0 && j == 0 )
     bignum.c line  853 - if( i > j ) return(  X->s );
     bignum.c line  854 - if( j > i ) return( -Y->s );
     bignum.c line  856 - if( X->s > 0 && Y->s < 0 ) return(  1 );
     bignum.c line  857 - if( Y->s > 0 && X->s < 0 ) return( -1 );
     bignum.c line  859 - for( ; i > 0; i-- )
     bignum.c line  861 - if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
     bignum.c line  862 - if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );

     /* mbedtls_mpi_add_abs */
     bignum.c line  893 - if( X == B )
     bignum.c line  898 - if( X != A )
     bignum.c line  906 - for( j = B->n; j > 0; j-- )
     bignum.c line  907 - if( B->p[j - 1] != 0 )
     bignum.c line  917 - for( i = 0; i < j; i++, o++, p++ )
     bignum.c line  924 - while( c != 0 )
     bignum.c line  926 - if( i >= X->n )

     /* mpi_sub_hlp */
     bignum.c line  948 - for( i = c = 0; i < n; i++, s++, d++ )
     bignum.c line  954 - while( c != 0 )

     /* mbedtls_mpi_sub_abs */
     bignum.c line  975 - if( X == B )
     bignum.c line  981 - if( X != A )
     bignum.c line  991 - for( n = B->n; n > 0; n-- )
     bignum.c line  992 - if( B->p[n - 1] != 0 )

     /* mbedtls_mpi_add_mpi */
     bignum.c line 1011 - if( A->s * B->s < 0 )

     /* mbedtls_mpi_sub_mpi */
     bignum.c line 1042 - if( A->s * B->s > 0 )

     /* mpi_mul_hlp */
     bignum.c line 1128 - for( ; i >= 16; i -= 16 )
     bignum.c line 1143 - for( ; i >= 8; i -= 8 )
     bignum.c line 1154 - for( ; i > 0; i-- )
     bignum.c line 1166 - }

     /* mbedtls_mpi_mul_mpi */
     bignum.c line 1184 - for( i = A->n; i > 0; i-- )
     bignum.c line 1185 - if( A->p[i - 1] != 0 )
     bignum.c line 1188 - for( j = B->n; j > 0; j-- )
     bignum.c line 1189 - if( B->p[j - 1] != 0 )
     bignum.c line 1195 - for( i++; j > 0; j-- )

     /* mbedtls_int_div_int */
     bignum.c line 1243 - if( 0 == d || u1 >= d )
     bignum.c line 1254 - if( quotient > ( (mbedtls_t_udbl) 1 << biL ) - 1 )

     /* mbedtls_mpi_div_mpi */
     bignum.c line 1328 - if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
     bignum.c line 1351 - if( k < biL - 1 )
     bignum.c line 1363 - while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
     bignum.c line 1370 - for( i = n; i > t ; i-- )
     bignum.c line 1372 - if( X.p[i] >= Y.p[t] )
     bignum.c line 1386 - T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
     bignum.c line 1391 - T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
     bignum.c line 1392 - T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
     bignum.c line 1394 - }
     bignum.c line 1401 - if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
     bignum.c line 1422 - if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )

     /* mbedtls_mpi_mod_mpi */
     bignum.c line 1457 - if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
     bignum.c line 1462 - while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
     bignum.c line 1465 - while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )

     /* mpi_montmul */
     bignum.c line 1556 - if( T->n < N->n + 1 || T->p == NULL )
     bignum.c line 1563 - m = ( B->n < n ) ? B->n : n;
     bignum.c line 1565 - for( i = 0; i < n; i++ )

     /* mbedtls_mpi_exp_mod */
VH   bignum.c line 1617 - if( mbedtls_mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 ) // Branc on `N` input validation
VH   bignum.c line 1620 - if( mbedtls_mpi_cmp_int( E, 0 ) < 0 ) // Branch on `E` input validation
UH   bignum.c line 1633 - wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :  // Branch on `E` wsize 
UH   bignum.c line 1634 - ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
VH   bignum.c line 1636 - if( wsize > MBEDTLS_MPI_WINDOW_SIZE ) // Branch on wsize based on length `E`
UH   bignum.c line 1648 - if( neg ) // Branch on A(?) tained later maybe
VH   bignum.c line 1658 - if( _RR == NULL || _RR->p == NULL ) // Branch on ptr, tainted later
UH   bignum.c line 1673 - if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 ) // Branch between plaintext and mod
UH   bignum.c line 1686 - if( wsize > 1 ) // branch on `E` length
RH   bignum.c line 1696 - for( i = 0; i < wsize - 1; i++ ) // Repeated branch; Fixed iteration loop
RH   bignum.c line 1702 - for( i = j + 1; i < ( one << wsize ); i++ ) // Repeated branch; fixed # iteration loop
RH   bignum.c line 1721 - if( nblimbs == 0 ) // Repeated branch in loop, based on limbs in E
RL   bignum.c line 1736 - if( ei == 0 && state == 0 ) // Repeated branch in loop, key dependent
RL   bignum.c line 1739 - if( ei == 0 && state == 1 ) // Repeated branch in loop, key dependent
RH   bignum.c line 1756 - if( nbits == wsize ) // Branch on length of E repeated
RH   bignum.c line 1761 - for( i = 0; i < wsize; i++ ) // Nested loop, repeated branch fixed number fixed # of iter.
RH   bignum.c line 1778 - for( i = 0; i < nbits; i++ ) // Branch on nbits 
RH   bignum.c line 1784 - if( ( wbits & ( one << wsize ) ) != 0 ) //  branch on key
RH   bignum.c line 1793 - if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 ) // Branch on E data
RH   bignum.c line 1801 - for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ ) // Repeated branch fixed # iter
UH   bignum.c line 1806 - if( _RR == NULL || _RR->p == NULL ) // Branch on pointer
   #+END_SRC
   
*** Classification
    | Err. Type        | Qty | Comments                                                      |
    | False Positive   |   0 |                                                               |
    | Validation       |   4 |                                                               |
    | Looped Branch    |  11 |                                                               |
    | Un-looped Branch |   6 |                                                               |
    | High entropy     |  19 | The high entropy results are mostly on size of various inputs |
    | Low entropy      |   2 | All of the low entropy results are on looped branches         |
    | Total Reported   |  21 |                                                               |

** bignum.c Commit *d47280a59f*
*** Without whitelist
   Tainted/Untrusted: N 2, E 2
   Entry: mbedtls_mpi_exp_mod
   
   #+BEGIN_SRC c
          bignum.c line   97 - if( X == NULL )
          bignum.c line  100 - if( X->p != NULL )
          bignum.c line  118 - if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
          bignum.c line  121 - if( X->n < nblimbs )
          bignum.c line  123 - if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
          bignum.c line  126 - if( X->p != NULL )
          bignum.c line  185 - if( X == Y )
          bignum.c line  188 - if( Y->p == NULL )
          bignum.c line  194 - for( i = Y->n - 1; i > 0; i-- )
          bignum.c line  195 - if( Y->p[i] != 0 )
          bignum.c line  369 - if( x & mask ) break;
          bignum.c line  384 - if( X->n == 0 )
          bignum.c line  387 - for( i = X->n - 1; i > 0; i-- )
          bignum.c line  388 - if( X->p[i] != 0 )
          bignum.c line  726 - if( X->n * biL < i )
          bignum.c line  734 - if( v0 > 0 )
          bignum.c line  736 - for( i = X->n; i > v0; i-- )
          bignum.c line  739 - for( ; i > 0; i-- )
          bignum.c line  746 - if( t1 > 0 )
          bignum.c line  748 - for( i = v0; i < X->n; i++ )
          bignum.c line  773 - if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
          bignum.c line  779 - if( v0 > 0 )
          bignum.c line  781 - for( i = 0; i < X->n - v0; i++ )
          bignum.c line  784 - for( ; i < X->n; i++ )
          bignum.c line  791 - if( v1 > 0 )
          bignum.c line  793 - for( i = X->n; i > 0; i-- )
          bignum.c line  812 - for( i = X->n; i > 0; i-- )
          bignum.c line  813 - if( X->p[i - 1] != 0 )
          bignum.c line  816 - for( j = Y->n; j > 0; j-- )
          bignum.c line  817 - if( Y->p[j - 1] != 0 )
          bignum.c line  820 - if( i == 0 && j == 0 )
          bignum.c line  823 - if( i > j ) return(  1 );
          bignum.c line  824 - if( j > i ) return( -1 );
          bignum.c line  826 - for( ; i > 0; i-- )
          bignum.c line  828 - if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
          bignum.c line  829 - if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
          bignum.c line  842 - for( i = X->n; i > 0; i-- )
          bignum.c line  843 - if( X->p[i - 1] != 0 )
          bignum.c line  846 - for( j = Y->n; j > 0; j-- )
          bignum.c line  847 - if( Y->p[j - 1] != 0 )
          bignum.c line  850 - if( i == 0 && j == 0 )
          bignum.c line  853 - if( i > j ) return(  X->s );
          bignum.c line  854 - if( j > i ) return( -Y->s );
          bignum.c line  856 - if( X->s > 0 && Y->s < 0 ) return(  1 );
          bignum.c line  857 - if( Y->s > 0 && X->s < 0 ) return( -1 );
          bignum.c line  859 - for( ; i > 0; i-- )
          bignum.c line  861 - if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
          bignum.c line  862 - if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
          bignum.c line  906 - for( j = B->n; j > 0; j-- )
          bignum.c line  907 - if( B->p[j - 1] != 0 )
          bignum.c line  917 - for( i = 0; i < j; i++, o++, p++ )
          bignum.c line  924 - while( c != 0 )
          bignum.c line  926 - if( i >= X->n )
          bignum.c line  948 - for( i = c = 0; i < n; i++, s++, d++ )
          bignum.c line  954 - while( c != 0 )
          bignum.c line  991 - for( n = B->n; n > 0; n-- )
          bignum.c line  992 - if( B->p[n - 1] != 0 )
          bignum.c line 1011 - if( A->s * B->s < 0 )
          bignum.c line 1042 - if( A->s * B->s > 0 )
          bignum.c line 1128 - for( ; i >= 16; i -= 16 )
          bignum.c line 1143 - for( ; i >= 8; i -= 8 )
          bignum.c line 1154 - for( ; i > 0; i-- )
          bignum.c line 1166 - }
          bignum.c line 1184 - for( i = A->n; i > 0; i-- )
          bignum.c line 1185 - if( A->p[i - 1] != 0 )
          bignum.c line 1188 - for( j = B->n; j > 0; j-- )
          bignum.c line 1189 - if( B->p[j - 1] != 0 )
          bignum.c line 1195 - for( i++; j > 0; j-- )
          bignum.c line 1243 - if( 0 == d || u1 >= d )
          bignum.c line 1254 - if( quotient > ( (mbedtls_t_udbl) 1 << biL ) - 1 )
          bignum.c line 1328 - if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
          bignum.c line 1351 - if( k < biL - 1 )
          bignum.c line 1363 - while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
          bignum.c line 1370 - for( i = n; i > t ; i-- )
          bignum.c line 1372 - if( X.p[i] >= Y.p[t] )
          bignum.c line 1386 - T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
          bignum.c line 1391 - T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
          bignum.c line 1392 - T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
          bignum.c line 1394 - }
          bignum.c line 1401 - if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
          bignum.c line 1422 - if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
          bignum.c line 1457 - if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
          bignum.c line 1462 - while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
          bignum.c line 1465 - while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
          bignum.c line 1556 - if( T->n < N->n + 1 || T->p == NULL )
          bignum.c line 1563 - m = ( B->n < n ) ? B->n : n;
          bignum.c line 1565 - for( i = 0; i < n; i++ )

          /* mbedtls_mpi_exp_mod */
     V    bignum.c line 1617 - if( mbedtls_mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
     V    bignum.c line 1620 - if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
     UL   bignum.c line 1633 - wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
     UL   bignum.c line 1634 - ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
     V    bignum.c line 1636 - if( wsize > MBEDTLS_MPI_WINDOW_SIZE )
     UL   bignum.c line 1648 - if( neg )
     V    bignum.c line 1658 - if( _RR == NULL || _RR->p == NULL )
     C   bignum.c line 1673 - if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
     UL   bignum.c line 1686 - if( wsize > 1 )
     RL   bignum.c line 1696 - for( i = 0; i < wsize - 1; i++ )
     RL   bignum.c line 1702 - for( i = j + 1; i < ( one << wsize ); i++ )
     RL   bignum.c line 1721 - if( nblimbs == 0 )
     RH   bignum.c line 1736 - if( ei == 0 && state == 0 )
     RH   bignum.c line 1739 - if( ei == 0 && state == 1 )
     RL   bignum.c line 1756 - if( nbits == wsize )
     RL   bignum.c line 1761 - for( i = 0; i < wsize; i++ )
     RL   bignum.c line 1778 - for( i = 0; i < nbits; i++ )
     RH   bignum.c line 1784 - if( ( wbits & ( one << wsize ) ) != 0 )
     UL   bignum.c line 1793 - if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
     RL     bignum.c line 1801 - for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
     V     bignum.c line 1806 - if( _RR == NULL || _RR->p == NULL )
   #+END_SRC
   
*** With whitelist
    Tainted/Untrusted: N 2, E 2
    Entry: mbedtls_mpi_exp_mod
    
    #+BEGIN_SRC c
V     bignum.c line 1617 - if( mbedtls_mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
V     bignum.c line 1620 - if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
UL    bignum.c line 1633 - wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
UL    bignum.c line 1634 - ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
UL    bignum.c line 1648 - if( neg )
V     bignum.c line 1658 - if( _RR == NULL || _RR->p == NULL )
C     bignum.c line 1673 - if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
FP/RL bignum.c line 1696 - for( i = 0; i < wsize - 1; i++ )
FP/RL bignum.c line 1702 - for( i = j + 1; i < ( one << wsize ); i++ )
UL    bignum.c line 1721 - if( nblimbs == 0 )
RH    bignum.c line 1736 - if( ei == 0 && state == 0 )
RH    bignum.c line 1739 - if( ei == 0 && state == 1 )
FP/RL bignum.c line 1761 - for( i = 0; i < wsize; i++ )
FP/RL bignum.c line 1778 - for( i = 0; i < nbits; i++ )
RH    bignum.c line 1784 - if( ( wbits & ( one << wsize ) ) != 0 )
UL    bignum.c line 1793 - if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
FP/RL bignum.c line 1801 - for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
V      bignum.c line 1806 - if( _RR == NULL || _RR->p == NULL )
    #+END_SRC
* Classification Hueristic
** Argument validation/Error Checking
** Frequency of Occurence
*** Single Occurence
    Branches which only occur one time 
    Examples:
    + Window size : bn_exp.c (OpenSSL 1.1.0g)  line 1289
                    bignum.c (mbedtls 2.9.0) line 1633
    + Exponent Length : bn_exp.c (OpenSSL 1.1.0g)  line 1263
                        bignum.c (mbedtls 2.9.0)  1631
*** Multiple occurence
    Branches which occur multiple times - most frequenty on differing parts of the key
    Examples:
    + Leading/Trailing zeros in  Window: bn_exp.c (OpenSSL 1.1.0g)  line 1312
                                         mpi-pow.c (LibGcrypt 1.8.2) line 667
                                         bignum.c (mbedtls 2.9.0) line  1736 & 1739
    + Nested Loops with changing iterations: mpi-pow.c line 667
                      
** Entropy
   A branch is a direct branch if it is on a value which can be uniquely computed from tainted data
   Examples:
   + Test for pointer equality: mpi-pow.c 529
   + Tests on values from sensitive data: mpi-pow.c 559
                                          bn_exp.c 740
   A branch is derived if the variable tested in the condition can have the same value from more than one tainted value
   Examples:
   +Window size 
   +Exponent length 
   +Number of limbs
   +Sign (A->neg) 
   
** Results Summary 
   
   
  +-------------+----------+----------+----------+----------+-----------+-----------+
  |             |       Entropy       |       Branch        |           |           |
  +-------------+----------+----------+----------+----------+-----------+-----------+
  |Library      | Low      |High      |Looped    |Single    | Validation|    F P    |
  +-------------+----------+----------+----------+----------+-----------+-----------+
  |OpenSSL1.1.0g|2         |9         |6         |5         |8          |0          |
  |Simple       |          |          |          |          |           |           |
  +-------------+----------+----------+----------+----------+-----------+-----------+
  |1.1.0g       |1         |16        |7         |10        |11         |0          |
  |mont_word    |          |          |          |          |           |           |
  +-------------+----------+----------+----------+----------+-----------+-----------+
  |1.1.0g       |1         |16        |7         |10        |11         |0          |
  |mont_word    |          |          |          |          |           |           |
  +-------------+----------+----------+----------+----------+-----------+-----------+

